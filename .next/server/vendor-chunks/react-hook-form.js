"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-hook-form";
exports.ids = ["vendor-chunks/react-hook-form"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/react-hook-form/dist/index.esm.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   FormProvider: () => (/* binding */ FormProvider),\n/* harmony export */   appendErrors: () => (/* binding */ appendErrors),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   useController: () => (/* binding */ useController),\n/* harmony export */   useFieldArray: () => (/* binding */ useFieldArray),\n/* harmony export */   useForm: () => (/* binding */ useForm),\n/* harmony export */   useFormContext: () => (/* binding */ useFormContext),\n/* harmony export */   useFormState: () => (/* binding */ useFormState),\n/* harmony export */   useWatch: () => (/* binding */ useWatch)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar isCheckBoxInput = (element)=>element.type === \"checkbox\";\nvar isDateObject = (value1)=>value1 instanceof Date;\nvar isNullOrUndefined = (value1)=>value1 == null;\nconst isObjectType = (value1)=>typeof value1 === \"object\";\nvar isObject = (value1)=>!isNullOrUndefined(value1) && !Array.isArray(value1) && isObjectType(value1) && !isDateObject(value1);\nvar getEventValue = (event)=>isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;\nvar getNodeParentName = (name)=>name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\nvar isNameInFieldArray = (names, name)=>names.has(getNodeParentName(name));\nvar isPlainObject = (tempObject)=>{\n    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;\n    return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty(\"isPrototypeOf\");\n};\nvar isWeb =  false && 0;\nfunction cloneObject(data) {\n    let copy;\n    const isArray = Array.isArray(data);\n    if (data instanceof Date) {\n        copy = new Date(data);\n    } else if (data instanceof Set) {\n        copy = new Set(data);\n    } else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) && (isArray || isObject(data))) {\n        copy = isArray ? [] : {};\n        if (!isArray && !isPlainObject(data)) {\n            copy = data;\n        } else {\n            for(const key in data){\n                if (data.hasOwnProperty(key)) {\n                    copy[key] = cloneObject(data[key]);\n                }\n            }\n        }\n    } else {\n        return data;\n    }\n    return copy;\n}\nvar compact = (value1)=>Array.isArray(value1) ? value1.filter(Boolean) : [];\nvar isUndefined = (val)=>val === undefined;\nvar get = (obj, path, defaultValue)=>{\n    if (!path || !isObject(obj)) {\n        return defaultValue;\n    }\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key)=>isNullOrUndefined(result) ? result : result[key], obj);\n    return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\nvar isBoolean = (value1)=>typeof value1 === \"boolean\";\nconst EVENTS = {\n    BLUR: \"blur\",\n    FOCUS_OUT: \"focusout\",\n    CHANGE: \"change\"\n};\nconst VALIDATION_MODE = {\n    onBlur: \"onBlur\",\n    onChange: \"onChange\",\n    onSubmit: \"onSubmit\",\n    onTouched: \"onTouched\",\n    all: \"all\"\n};\nconst INPUT_VALIDATION_RULES = {\n    max: \"max\",\n    min: \"min\",\n    maxLength: \"maxLength\",\n    minLength: \"minLength\",\n    pattern: \"pattern\",\n    required: \"required\",\n    validate: \"validate\"\n};\nconst HookFormContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @returns return all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const useFormContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(HookFormContext);\n/**\n * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @param props - all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const FormProvider = (props)=>{\n    const { children, ...data } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HookFormContext.Provider, {\n        value: data\n    }, children);\n};\nvar getProxyFormState = (formState, control, localProxyFormState, isRoot = true)=>{\n    const result = {\n        defaultValues: control._defaultValues\n    };\n    for(const key in formState){\n        Object.defineProperty(result, key, {\n            get: ()=>{\n                const _key = key;\n                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {\n                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;\n                }\n                localProxyFormState && (localProxyFormState[_key] = true);\n                return formState[_key];\n            }\n        });\n    }\n    return result;\n};\nvar isEmptyObject = (value1)=>isObject(value1) && !Object.keys(value1).length;\nvar shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot)=>{\n    updateFormState(formStateData);\n    const { name, ...formState } = formStateData;\n    return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key)=>_proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));\n};\nvar convertToArrayPayload = (value1)=>Array.isArray(value1) ? value1 : [\n        value1\n    ];\nvar shouldSubscribeByName = (name, signalName, exact)=>!name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName)=>currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));\nfunction useSubscribe(props) {\n    const _props = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);\n    _props.current = props;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({\n            next: _props.current.next\n        });\n        return ()=>{\n            subscription && subscription.unsubscribe();\n        };\n    }, [\n        props.disabled\n    ]);\n}\n/**\n * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)\n *\n * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, control } = useForm({\n *     defaultValues: {\n *     firstName: \"firstName\"\n *   }});\n *   const { dirtyFields } = useFormState({\n *     control\n *   });\n *   const onSubmit = (data) => console.log(data);\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input {...register(\"firstName\")} placeholder=\"First Name\" />\n *       {dirtyFields.firstName && <p>Field is dirty.</p>}\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFormState(props) {\n    const methods = useFormContext();\n    const { control = methods.control, disabled, name, exact } = props || {};\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._formState);\n    const _mounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        isDirty: false,\n        isLoading: false,\n        dirtyFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    });\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    _name.current = name;\n    useSubscribe({\n        disabled,\n        next: (value1)=>_mounted.current && shouldSubscribeByName(_name.current, value1.name, exact) && shouldRenderFormState(value1, _localProxyFormState.current, control._updateFormState) && updateFormState({\n                ...control._formState,\n                ...value1\n            }),\n        subject: control._subjects.state\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        _mounted.current = true;\n        _localProxyFormState.current.isValid && control._updateValid(true);\n        return ()=>{\n            _mounted.current = false;\n        };\n    }, [\n        control\n    ]);\n    return getProxyFormState(formState, control, _localProxyFormState.current, false);\n}\nvar isString = (value1)=>typeof value1 === \"string\";\nvar generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue)=>{\n    if (isString(names)) {\n        isGlobal && _names.watch.add(names);\n        return get(formValues, names, defaultValue);\n    }\n    if (Array.isArray(names)) {\n        return names.map((fieldName)=>(isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));\n    }\n    isGlobal && (_names.watchAll = true);\n    return formValues;\n};\n/**\n * Custom hook to subscribe to field change and isolate re-rendering at the component level.\n *\n * @remarks\n *\n * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)\n *\n * @example\n * ```tsx\n * const { control } = useForm();\n * const values = useWatch({\n *   name: \"fieldName\"\n *   control,\n * })\n * ```\n */ function useWatch(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, defaultValue, disabled, exact } = props || {};\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    _name.current = name;\n    useSubscribe({\n        disabled,\n        subject: control._subjects.values,\n        next: (formState)=>{\n            if (shouldSubscribeByName(_name.current, formState.name, exact)) {\n                updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));\n            }\n        }\n    });\n    const [value1, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getWatch(name, defaultValue));\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._removeUnmounted());\n    return value1;\n}\nvar isKey = (value1)=>/^\\w*$/.test(value1);\nvar stringToPath = (input)=>compact(input.replace(/[\"|']|\\]/g, \"\").split(/\\.|\\[/));\nfunction set(object, path, value1) {\n    let index = -1;\n    const tempPath = isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const length = tempPath.length;\n    const lastIndex = length - 1;\n    while(++index < length){\n        const key = tempPath[index];\n        let newValue = value1;\n        if (index !== lastIndex) {\n            const objValue = object[key];\n            newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n        }\n        object[key] = newValue;\n        object = object[key];\n    }\n    return object;\n}\n/**\n * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns field properties, field and form state. {@link UseControllerReturn}\n *\n * @example\n * ```tsx\n * function Input(props) {\n *   const { field, fieldState, formState } = useController(props);\n *   return (\n *     <div>\n *       <input {...field} placeholder={props.name} />\n *       <p>{fieldState.isTouched && \"Touched\"}</p>\n *       <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *     </div>\n *   );\n * }\n * ```\n */ function useController(props) {\n    const methods = useFormContext();\n    const { name, disabled, control = methods.control, shouldUnregister } = props;\n    const isArrayField = isNameInFieldArray(control._names.array, name);\n    const value1 = useWatch({\n        control,\n        name,\n        defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),\n        exact: true\n    });\n    const formState = useFormState({\n        control,\n        name\n    });\n    const _registerProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control.register(name, {\n        ...props.rules,\n        value: value1\n    }));\n    _registerProps.current = control.register(name, props.rules);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;\n        const updateMounted = (name, value1)=>{\n            const field = get(control._fields, name);\n            if (field) {\n                field._f.mount = value1;\n            }\n        };\n        updateMounted(name, true);\n        if (_shouldUnregisterField) {\n            const value1 = cloneObject(get(control._options.defaultValues, name));\n            set(control._defaultValues, name, value1);\n            if (isUndefined(get(control._formValues, name))) {\n                set(control._formValues, name, value1);\n            }\n        }\n        return ()=>{\n            (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        isArrayField,\n        shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (get(control._fields, name)) {\n            control._updateDisabledField({\n                disabled,\n                fields: control._fields,\n                name,\n                value: get(control._fields, name)._f.value\n            });\n        }\n    }, [\n        disabled,\n        name,\n        control\n    ]);\n    return {\n        field: {\n            name,\n            value: value1,\n            ...isBoolean(disabled) || isBoolean(formState.disabled) ? {\n                disabled: formState.disabled || disabled\n            } : {},\n            onChange: react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>_registerProps.current.onChange({\n                    target: {\n                        value: getEventValue(event),\n                        name: name\n                    },\n                    type: EVENTS.CHANGE\n                }), [\n                name\n            ]),\n            onBlur: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>_registerProps.current.onBlur({\n                    target: {\n                        value: get(control._formValues, name),\n                        name: name\n                    },\n                    type: EVENTS.BLUR\n                }), [\n                name,\n                control\n            ]),\n            ref: (elm)=>{\n                const field = get(control._fields, name);\n                if (field && elm) {\n                    field._f.ref = {\n                        focus: ()=>elm.focus(),\n                        select: ()=>elm.select(),\n                        setCustomValidity: (message)=>elm.setCustomValidity(message),\n                        reportValidity: ()=>elm.reportValidity()\n                    };\n                }\n            }\n        },\n        formState,\n        fieldState: Object.defineProperties({}, {\n            invalid: {\n                enumerable: true,\n                get: ()=>!!get(formState.errors, name)\n            },\n            isDirty: {\n                enumerable: true,\n                get: ()=>!!get(formState.dirtyFields, name)\n            },\n            isTouched: {\n                enumerable: true,\n                get: ()=>!!get(formState.touchedFields, name)\n            },\n            error: {\n                enumerable: true,\n                get: ()=>get(formState.errors, name)\n            }\n        })\n    };\n}\n/**\n * Component based on `useController` hook to work with controlled component.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns provide field handler functions, field and form state.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control } = useForm<FormValues>({\n *     defaultValues: {\n *       test: \"\"\n *     }\n *   });\n *\n *   return (\n *     <form>\n *       <Controller\n *         control={control}\n *         name=\"test\"\n *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (\n *           <>\n *             <input\n *               onChange={onChange} // send value to hook form\n *               onBlur={onBlur} // notify when input is touched\n *               value={value} // return updated value\n *               ref={ref} // set ref for focus management\n *             />\n *             <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *             <p>{fieldState.isTouched ? \"touched\" : \"\"}</p>\n *           </>\n *         )}\n *       />\n *     </form>\n *   );\n * }\n * ```\n */ const Controller = (props)=>props.render(useController(props));\nconst POST_REQUEST = \"post\";\n/**\n * Form component to manage submission.\n *\n * @param props - to setup submission detail. {@link FormProps}\n *\n * @returns form component or headless render prop.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control, formState: { errors } } = useForm();\n *\n *   return (\n *     <Form action=\"/api\" control={control}>\n *       <input {...register(\"name\")} />\n *       <p>{errors?.root?.server && 'Server error'}</p>\n *       <button>Submit</button>\n *     </Form>\n *   );\n * }\n * ```\n */ function Form(props) {\n    const methods = useFormContext();\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;\n    const submit = async (event)=>{\n        let hasError = false;\n        let type = \"\";\n        await control.handleSubmit(async (data)=>{\n            const formData = new FormData();\n            let formDataJson = \"\";\n            try {\n                formDataJson = JSON.stringify(data);\n            } catch (_a) {}\n            for (const name of control._names.mount){\n                formData.append(name, get(data, name));\n            }\n            if (onSubmit) {\n                await onSubmit({\n                    data,\n                    event,\n                    method,\n                    formData,\n                    formDataJson\n                });\n            }\n            if (action) {\n                try {\n                    const shouldStringifySubmissionData = [\n                        headers && headers[\"Content-Type\"],\n                        encType\n                    ].some((value1)=>value1 && value1.includes(\"json\"));\n                    const response = await fetch(action, {\n                        method,\n                        headers: {\n                            ...headers,\n                            ...encType ? {\n                                \"Content-Type\": encType\n                            } : {}\n                        },\n                        body: shouldStringifySubmissionData ? formDataJson : formData\n                    });\n                    if (response && (validateStatus ? !validateStatus(response.status) : response.status < 200 || response.status >= 300)) {\n                        hasError = true;\n                        onError && onError({\n                            response\n                        });\n                        type = String(response.status);\n                    } else {\n                        onSuccess && onSuccess({\n                            response\n                        });\n                    }\n                } catch (error) {\n                    hasError = true;\n                    onError && onError({\n                        error\n                    });\n                }\n            }\n        })(event);\n        if (hasError && props.control) {\n            props.control._subjects.state.next({\n                isSubmitSuccessful: false\n            });\n            props.control.setError(\"root.server\", {\n                type\n            });\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return render ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, render({\n        submit\n    })) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", {\n        noValidate: mounted,\n        action: action,\n        method: method,\n        encType: encType,\n        onSubmit: submit,\n        ...rest\n    }, children);\n}\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message)=>validateAllFieldCriteria ? {\n        ...errors[name],\n        types: {\n            ...errors[name] && errors[name].types ? errors[name].types : {},\n            [type]: message || true\n        }\n    } : {};\nvar generateId = ()=>{\n    const d = typeof performance === \"undefined\" ? Date.now() : performance.now() * 1000;\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = (Math.random() * 16 + d) % 16 | 0;\n        return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\nvar getFocusFieldName = (name, index, options = {})=>options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.` : \"\";\nvar getValidationModes = (mode)=>({\n        isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n        isOnBlur: mode === VALIDATION_MODE.onBlur,\n        isOnChange: mode === VALIDATION_MODE.onChange,\n        isOnAll: mode === VALIDATION_MODE.all,\n        isOnTouch: mode === VALIDATION_MODE.onTouched\n    });\nvar isWatched = (name, _names, isBlurEvent)=>!isBlurEvent && (_names.watchAll || _names.watch.has(name) || [\n        ..._names.watch\n    ].some((watchName)=>name.startsWith(watchName) && /^\\.\\w+/.test(name.slice(watchName.length))));\nconst iterateFieldsByAction = (fields, action, fieldsNames, abortEarly)=>{\n    for (const key of fieldsNames || Object.keys(fields)){\n        const field = get(fields, key);\n        if (field) {\n            const { _f, ...currentField } = field;\n            if (_f) {\n                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {\n                    break;\n                } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {\n                    break;\n                }\n            } else if (isObject(currentField)) {\n                iterateFieldsByAction(currentField, action);\n            }\n        }\n    }\n};\nvar updateFieldArrayRootError = (errors, error, name)=>{\n    const fieldArrayErrors = compact(get(errors, name));\n    set(fieldArrayErrors, \"root\", error[name]);\n    set(errors, name, fieldArrayErrors);\n    return errors;\n};\nvar isFileInput = (element)=>element.type === \"file\";\nvar isFunction = (value1)=>typeof value1 === \"function\";\nvar isHTMLElement = (value1)=>{\n    if (!isWeb) {\n        return false;\n    }\n    const owner = value1 ? value1.ownerDocument : 0;\n    return value1 instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);\n};\nvar isMessage = (value1)=>isString(value1);\nvar isRadioInput = (element)=>element.type === \"radio\";\nvar isRegex = (value1)=>value1 instanceof RegExp;\nconst defaultResult = {\n    value: false,\n    isValid: false\n};\nconst validResult = {\n    value: true,\n    isValid: true\n};\nvar getCheckboxValue = (options)=>{\n    if (Array.isArray(options)) {\n        if (options.length > 1) {\n            const values = options.filter((option)=>option && option.checked && !option.disabled).map((option)=>option.value);\n            return {\n                value: values,\n                isValid: !!values.length\n            };\n        }\n        return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === \"\" ? validResult : {\n            value: options[0].value,\n            isValid: true\n        } : validResult : defaultResult;\n    }\n    return defaultResult;\n};\nconst defaultReturn = {\n    isValid: false,\n    value: null\n};\nvar getRadioValue = (options)=>Array.isArray(options) ? options.reduce((previous, option)=>option && option.checked && !option.disabled ? {\n            isValid: true,\n            value: option.value\n        } : previous, defaultReturn) : defaultReturn;\nfunction getValidateError(result, ref, type = \"validate\") {\n    if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {\n        return {\n            type,\n            message: isMessage(result) ? result : \"\",\n            ref\n        };\n    }\n}\nvar getValueAndMessage = (validationData)=>isObject(validationData) && !isRegex(validationData) ? validationData : {\n        value: validationData,\n        message: \"\"\n    };\nvar validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray)=>{\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled } = field._f;\n    const inputValue = get(formValues, name);\n    if (!mount || disabled) {\n        return {};\n    }\n    const inputRef = refs ? refs[0] : ref;\n    const setCustomValidity = (message)=>{\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\n            inputRef.setCustomValidity(isBoolean(message) ? \"\" : message || \"\");\n            inputRef.reportValidity();\n        }\n    };\n    const error = {};\n    const isRadio = isRadioInput(ref);\n    const isCheckBox = isCheckBoxInput(ref);\n    const isRadioOrCheckbox = isRadio || isCheckBox;\n    const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === \"\" || inputValue === \"\" || Array.isArray(inputValue) && !inputValue.length;\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength)=>{\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\n        error[name] = {\n            type: exceedMax ? maxType : minType,\n            message,\n            ref,\n            ...appendErrorsCurry(exceedMax ? maxType : minType, message)\n        };\n    };\n    if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n        const { value: value1, message } = isMessage(required) ? {\n            value: !!required,\n            message: required\n        } : getValueAndMessage(required);\n        if (value1) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.required,\n                message,\n                ref: inputRef,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n        let exceedMax;\n        let exceedMin;\n        const maxOutput = getValueAndMessage(max);\n        const minOutput = getValueAndMessage(min);\n        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {\n            const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);\n            if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n            }\n            if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n            }\n        } else {\n            const valueDate = ref.valueAsDate || new Date(inputValue);\n            const convertTimeToDate = (time)=>new Date(new Date().toDateString() + \" \" + time);\n            const isTime = ref.type == \"time\";\n            const isWeek = ref.type == \"week\";\n            if (isString(maxOutput.value) && inputValue) {\n                exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);\n            }\n            if (isString(minOutput.value) && inputValue) {\n                exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);\n            }\n        }\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {\n        const maxLengthOutput = getValueAndMessage(maxLength);\n        const minLengthOutput = getValueAndMessage(minLength);\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if (pattern && !isEmpty && isString(inputValue)) {\n        const { value: patternValue, message } = getValueAndMessage(pattern);\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.pattern,\n                message,\n                ref,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (validate) {\n        if (isFunction(validate)) {\n            const result = await validate(inputValue, formValues);\n            const validateError = getValidateError(result, inputRef);\n            if (validateError) {\n                error[name] = {\n                    ...validateError,\n                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)\n                };\n                if (!validateAllFieldCriteria) {\n                    setCustomValidity(validateError.message);\n                    return error;\n                }\n            }\n        } else if (isObject(validate)) {\n            let validationResult = {};\n            for(const key in validate){\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n                    break;\n                }\n                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);\n                if (validateError) {\n                    validationResult = {\n                        ...validateError,\n                        ...appendErrorsCurry(key, validateError.message)\n                    };\n                    setCustomValidity(validateError.message);\n                    if (validateAllFieldCriteria) {\n                        error[name] = validationResult;\n                    }\n                }\n            }\n            if (!isEmptyObject(validationResult)) {\n                error[name] = {\n                    ref: inputRef,\n                    ...validationResult\n                };\n                if (!validateAllFieldCriteria) {\n                    return error;\n                }\n            }\n        }\n    }\n    setCustomValidity(true);\n    return error;\n};\nfunction append(data, value1) {\n    return [\n        ...data,\n        ...convertToArrayPayload(value1)\n    ];\n}\nvar fillEmptyArray = (value1)=>Array.isArray(value1) ? value1.map(()=>undefined) : undefined;\nfunction insert(data, index, value1) {\n    return [\n        ...data.slice(0, index),\n        ...convertToArrayPayload(value1),\n        ...data.slice(index)\n    ];\n}\nvar moveArrayAt = (data, from, to)=>{\n    if (!Array.isArray(data)) {\n        return [];\n    }\n    if (isUndefined(data[to])) {\n        data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n};\nfunction prepend(data, value1) {\n    return [\n        ...convertToArrayPayload(value1),\n        ...convertToArrayPayload(data)\n    ];\n}\nfunction removeAtIndexes(data, indexes) {\n    let i = 0;\n    const temp = [\n        ...data\n    ];\n    for (const index of indexes){\n        temp.splice(index - i, 1);\n        i++;\n    }\n    return compact(temp).length ? temp : [];\n}\nvar removeArrayAt = (data, index)=>isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b)=>a - b));\nvar swapArrayAt = (data, indexA, indexB)=>{\n    data[indexA] = [\n        data[indexB],\n        data[indexB] = data[indexA]\n    ][0];\n};\nfunction baseGet(object, updatePath) {\n    const length = updatePath.slice(0, -1).length;\n    let index = 0;\n    while(index < length){\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\n    }\n    return object;\n}\nfunction isEmptyArray(obj) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction unset(object, path) {\n    const paths = Array.isArray(path) ? path : isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const childObject = paths.length === 1 ? object : baseGet(object, paths);\n    const index = paths.length - 1;\n    const key = paths[index];\n    if (childObject) {\n        delete childObject[key];\n    }\n    if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {\n        unset(object, paths.slice(0, -1));\n    }\n    return object;\n}\nvar updateAt = (fieldValues, index, value1)=>{\n    fieldValues[index] = value1;\n    return fieldValues;\n};\n/**\n * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)\n *\n * @param props - useFieldArray props\n *\n * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({\n *     defaultValues: {\n *       test: []\n *     }\n *   });\n *   const { fields, append } = useFieldArray({\n *     control,\n *     name: \"test\"\n *   });\n *\n *   return (\n *     <form onSubmit={handleSubmit(data => console.log(data))}>\n *       {fields.map((item, index) => (\n *          <input key={item.id} {...register(`test.${index}.firstName`)}  />\n *       ))}\n *       <button type=\"button\" onClick={() => append({ firstName: \"bill\" })}>\n *         append\n *       </button>\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFieldArray(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, keyName = \"id\", shouldUnregister } = props;\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getFieldArray(name));\n    const ids = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control._getFieldArray(name).map(generateId));\n    const _fieldIds = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fields);\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    const _actioned = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    _name.current = name;\n    _fieldIds.current = fields;\n    control._names.array.add(name);\n    props.rules && control.register(name, props.rules);\n    useSubscribe({\n        next: ({ values, name: fieldArrayName })=>{\n            if (fieldArrayName === _name.current || !fieldArrayName) {\n                const fieldValues = get(values, _name.current);\n                if (Array.isArray(fieldValues)) {\n                    setFields(fieldValues);\n                    ids.current = fieldValues.map(generateId);\n                }\n            }\n        },\n        subject: control._subjects.array\n    });\n    const updateValues = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((updatedFieldArrayValues)=>{\n        _actioned.current = true;\n        control._updateFieldArray(name, updatedFieldArrayValues);\n    }, [\n        control,\n        name\n    ]);\n    const append$1 = (value1, options)=>{\n        const appendValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = append(control._getFieldArray(name), appendValue);\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);\n        ids.current = append(ids.current, appendValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, append, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const prepend$1 = (value1, options)=>{\n        const prependValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = prepend(control._getFieldArray(name), prependValue);\n        control._names.focus = getFocusFieldName(name, 0, options);\n        ids.current = prepend(ids.current, prependValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, prepend, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const remove = (index)=>{\n        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);\n        ids.current = removeArrayAt(ids.current, index);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, removeArrayAt, {\n            argA: index\n        });\n    };\n    const insert$1 = (index, value1, options)=>{\n        const insertValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);\n        control._names.focus = getFocusFieldName(name, index, options);\n        ids.current = insert(ids.current, index, insertValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, insert, {\n            argA: index,\n            argB: fillEmptyArray(value1)\n        });\n    };\n    const swap = (indexA, indexB)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        swapArrayAt(updatedFieldArrayValues, indexA, indexB);\n        swapArrayAt(ids.current, indexA, indexB);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, swapArrayAt, {\n            argA: indexA,\n            argB: indexB\n        }, false);\n    };\n    const move = (from, to)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        moveArrayAt(updatedFieldArrayValues, from, to);\n        moveArrayAt(ids.current, from, to);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, moveArrayAt, {\n            argA: from,\n            argB: to\n        }, false);\n    };\n    const update = (index, value1)=>{\n        const updateValue = cloneObject(value1);\n        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);\n        ids.current = [\n            ...updatedFieldArrayValues\n        ].map((item, i)=>!item || i === index ? generateId() : ids.current[i]);\n        updateValues(updatedFieldArrayValues);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._updateFieldArray(name, updatedFieldArrayValues, updateAt, {\n            argA: index,\n            argB: updateValue\n        }, true, false);\n    };\n    const replace = (value1)=>{\n        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value1));\n        ids.current = updatedFieldArrayValues.map(generateId);\n        updateValues([\n            ...updatedFieldArrayValues\n        ]);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._updateFieldArray(name, [\n            ...updatedFieldArrayValues\n        ], (data)=>data, {}, true, false);\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._state.action = false;\n        isWatched(name, control._names) && control._subjects.state.next({\n            ...control._formState\n        });\n        if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted)) {\n            if (control._options.resolver) {\n                control._executeSchema([\n                    name\n                ]).then((result)=>{\n                    const error = get(result.errors, name);\n                    const existingError = get(control._formState.errors, name);\n                    if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {\n                        error ? set(control._formState.errors, name, error) : unset(control._formState.errors, name);\n                        control._subjects.state.next({\n                            errors: control._formState.errors\n                        });\n                    }\n                });\n            } else {\n                const field = get(control._fields, name);\n                if (field && field._f) {\n                    validateField(field, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error)=>!isEmptyObject(error) && control._subjects.state.next({\n                            errors: updateFieldArrayRootError(control._formState.errors, error, name)\n                        }));\n                }\n            }\n        }\n        control._subjects.values.next({\n            name,\n            values: {\n                ...control._formValues\n            }\n        });\n        control._names.focus && iterateFieldsByAction(control._fields, (ref, key)=>{\n            if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {\n                ref.focus();\n                return 1;\n            }\n            return;\n        });\n        control._names.focus = \"\";\n        control._updateValid();\n        _actioned.current = false;\n    }, [\n        fields,\n        name,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        !get(control._formValues, name) && control._updateFieldArray(name);\n        return ()=>{\n            (control._options.shouldUnregister || shouldUnregister) && control.unregister(name);\n        };\n    }, [\n        name,\n        control,\n        keyName,\n        shouldUnregister\n    ]);\n    return {\n        swap: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(swap, [\n            updateValues,\n            name,\n            control\n        ]),\n        move: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(move, [\n            updateValues,\n            name,\n            control\n        ]),\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(prepend$1, [\n            updateValues,\n            name,\n            control\n        ]),\n        append: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(append$1, [\n            updateValues,\n            name,\n            control\n        ]),\n        remove: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(remove, [\n            updateValues,\n            name,\n            control\n        ]),\n        insert: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(insert$1, [\n            updateValues,\n            name,\n            control\n        ]),\n        update: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(update, [\n            updateValues,\n            name,\n            control\n        ]),\n        replace: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(replace, [\n            updateValues,\n            name,\n            control\n        ]),\n        fields: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>fields.map((field, index)=>({\n                    ...field,\n                    [keyName]: ids.current[index] || generateId()\n                })), [\n            fields,\n            keyName\n        ])\n    };\n}\nfunction createSubject() {\n    let _observers = [];\n    const next = (value1)=>{\n        for (const observer of _observers){\n            observer.next && observer.next(value1);\n        }\n    };\n    const subscribe = (observer)=>{\n        _observers.push(observer);\n        return {\n            unsubscribe: ()=>{\n                _observers = _observers.filter((o)=>o !== observer);\n            }\n        };\n    };\n    const unsubscribe = ()=>{\n        _observers = [];\n    };\n    return {\n        get observers () {\n            return _observers;\n        },\n        next,\n        subscribe,\n        unsubscribe\n    };\n}\nvar isPrimitive = (value1)=>isNullOrUndefined(value1) || !isObjectType(value1);\nfunction deepEqual(object1, object2) {\n    if (isPrimitive(object1) || isPrimitive(object2)) {\n        return object1 === object2;\n    }\n    if (isDateObject(object1) && isDateObject(object2)) {\n        return object1.getTime() === object2.getTime();\n    }\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1){\n        const val1 = object1[key];\n        if (!keys2.includes(key)) {\n            return false;\n        }\n        if (key !== \"ref\") {\n            const val2 = object2[key];\n            if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nvar isMultipleSelect = (element)=>element.type === `select-multiple`;\nvar isRadioOrCheckbox = (ref)=>isRadioInput(ref) || isCheckBoxInput(ref);\nvar live = (ref)=>isHTMLElement(ref) && ref.isConnected;\nvar objectHasFunction = (data)=>{\n    for(const key in data){\n        if (isFunction(data[key])) {\n            return true;\n        }\n    }\n    return false;\n};\nfunction markFieldsDirty(data, fields = {}) {\n    const isParentNodeArray = Array.isArray(data);\n    if (isObject(data) || isParentNodeArray) {\n        for(const key in data){\n            if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {\n                fields[key] = Array.isArray(data[key]) ? [] : {};\n                markFieldsDirty(data[key], fields[key]);\n            } else if (!isNullOrUndefined(data[key])) {\n                fields[key] = true;\n            }\n        }\n    }\n    return fields;\n}\nfunction getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {\n    const isParentNodeArray = Array.isArray(data);\n    if (isObject(data) || isParentNodeArray) {\n        for(const key in data){\n            if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {\n                if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {\n                    dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : {\n                        ...markFieldsDirty(data[key])\n                    };\n                } else {\n                    getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);\n                }\n            } else {\n                dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);\n            }\n        }\n    }\n    return dirtyFieldsFromValues;\n}\nvar getDirtyFields = (defaultValues, formValues)=>getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));\nvar getFieldValueAs = (value1, { valueAsNumber, valueAsDate, setValueAs })=>isUndefined(value1) ? value1 : valueAsNumber ? value1 === \"\" ? NaN : value1 ? +value1 : value1 : valueAsDate && isString(value1) ? new Date(value1) : setValueAs ? setValueAs(value1) : value1;\nfunction getFieldValue(_f) {\n    const ref = _f.ref;\n    if (_f.refs ? _f.refs.every((ref)=>ref.disabled) : ref.disabled) {\n        return;\n    }\n    if (isFileInput(ref)) {\n        return ref.files;\n    }\n    if (isRadioInput(ref)) {\n        return getRadioValue(_f.refs).value;\n    }\n    if (isMultipleSelect(ref)) {\n        return [\n            ...ref.selectedOptions\n        ].map(({ value: value1 })=>value1);\n    }\n    if (isCheckBoxInput(ref)) {\n        return getCheckboxValue(_f.refs).value;\n    }\n    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);\n}\nvar getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation)=>{\n    const fields = {};\n    for (const name of fieldsNames){\n        const field = get(_fields, name);\n        field && set(fields, name, field._f);\n    }\n    return {\n        criteriaMode,\n        names: [\n            ...fieldsNames\n        ],\n        fields,\n        shouldUseNativeValidation\n    };\n};\nvar getRuleValue = (rule)=>isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;\nvar hasValidation = (options)=>options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);\nfunction schemaErrorLookup(errors, _fields, name) {\n    const error = get(errors, name);\n    if (error || isKey(name)) {\n        return {\n            error,\n            name\n        };\n    }\n    const names = name.split(\".\");\n    while(names.length){\n        const fieldName = names.join(\".\");\n        const field = get(_fields, fieldName);\n        const foundError = get(errors, fieldName);\n        if (field && !Array.isArray(field) && name !== fieldName) {\n            return {\n                name\n            };\n        }\n        if (foundError && foundError.type) {\n            return {\n                name: fieldName,\n                error: foundError\n            };\n        }\n        names.pop();\n    }\n    return {\n        name\n    };\n}\nvar skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode)=>{\n    if (mode.isOnAll) {\n        return false;\n    } else if (!isSubmitted && mode.isOnTouch) {\n        return !(isTouched || isBlurEvent);\n    } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\n        return !isBlurEvent;\n    } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\n        return isBlurEvent;\n    }\n    return true;\n};\nvar unsetEmptyArray = (ref, name)=>!compact(get(ref, name)).length && unset(ref, name);\nconst defaultOptions = {\n    mode: VALIDATION_MODE.onSubmit,\n    reValidateMode: VALIDATION_MODE.onChange,\n    shouldFocusError: true\n};\nfunction createFormControl(props = {}, flushRootRender) {\n    let _options = {\n        ...defaultOptions,\n        ...props\n    };\n    let _formState = {\n        submitCount: 0,\n        isDirty: false,\n        isLoading: isFunction(_options.defaultValues),\n        isValidating: false,\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        touchedFields: {},\n        dirtyFields: {},\n        errors: {},\n        disabled: false\n    };\n    let _fields = {};\n    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};\n    let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);\n    let _state = {\n        action: false,\n        mount: false,\n        watch: false\n    };\n    let _names = {\n        mount: new Set(),\n        unMount: new Set(),\n        array: new Set(),\n        watch: new Set()\n    };\n    let delayErrorCallback;\n    let timer = 0;\n    const _proxyFormState = {\n        isDirty: false,\n        dirtyFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    };\n    const _subjects = {\n        values: createSubject(),\n        array: createSubject(),\n        state: createSubject()\n    };\n    const shouldCaptureDirtyFields = props.resetOptions && props.resetOptions.keepDirtyValues;\n    const validationModeBeforeSubmit = getValidationModes(_options.mode);\n    const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);\n    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;\n    const debounce = (callback)=>(wait)=>{\n            clearTimeout(timer);\n            timer = setTimeout(callback, wait);\n        };\n    const _updateValid = async (shouldUpdateValid)=>{\n        if (_proxyFormState.isValid || shouldUpdateValid) {\n            const isValid = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);\n            if (isValid !== _formState.isValid) {\n                _subjects.state.next({\n                    isValid\n                });\n            }\n        }\n    };\n    const _updateIsValidating = (value1)=>_proxyFormState.isValidating && _subjects.state.next({\n            isValidating: value1\n        });\n    const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true)=>{\n        if (args && method) {\n            _state.action = true;\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {\n                const fieldValues = method(get(_fields, name), args.argA, args.argB);\n                shouldSetValues && set(_fields, name, fieldValues);\n            }\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {\n                const errors = method(get(_formState.errors, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.errors, name, errors);\n                unsetEmptyArray(_formState.errors, name);\n            }\n            if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {\n                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.touchedFields, name, touchedFields);\n            }\n            if (_proxyFormState.dirtyFields) {\n                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);\n            }\n            _subjects.state.next({\n                name,\n                isDirty: _getDirty(name, values),\n                dirtyFields: _formState.dirtyFields,\n                errors: _formState.errors,\n                isValid: _formState.isValid\n            });\n        } else {\n            set(_formValues, name, values);\n        }\n    };\n    const updateErrors = (name, error)=>{\n        set(_formState.errors, name, error);\n        _subjects.state.next({\n            errors: _formState.errors\n        });\n    };\n    const updateValidAndValue = (name, shouldSkipSetValueAs, value1, ref)=>{\n        const field = get(_fields, name);\n        if (field) {\n            const defaultValue = get(_formValues, name, isUndefined(value1) ? get(_defaultValues, name) : value1);\n            isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);\n            _state.mount && _updateValid();\n        }\n    };\n    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender)=>{\n        let shouldUpdateField = false;\n        let isPreviousDirty = false;\n        const output = {\n            name\n        };\n        if (!isBlurEvent || shouldDirty) {\n            if (_proxyFormState.isDirty) {\n                isPreviousDirty = _formState.isDirty;\n                _formState.isDirty = output.isDirty = _getDirty();\n                shouldUpdateField = isPreviousDirty !== output.isDirty;\n            }\n            const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);\n            isPreviousDirty = get(_formState.dirtyFields, name);\n            isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);\n            output.dirtyFields = _formState.dirtyFields;\n            shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;\n        }\n        if (isBlurEvent) {\n            const isPreviousFieldTouched = get(_formState.touchedFields, name);\n            if (!isPreviousFieldTouched) {\n                set(_formState.touchedFields, name, isBlurEvent);\n                output.touchedFields = _formState.touchedFields;\n                shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;\n            }\n        }\n        shouldUpdateField && shouldRender && _subjects.state.next(output);\n        return shouldUpdateField ? output : {};\n    };\n    const shouldRenderByError = (name, isValid, error, fieldState)=>{\n        const previousFieldError = get(_formState.errors, name);\n        const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid) && _formState.isValid !== isValid;\n        if (props.delayError && error) {\n            delayErrorCallback = debounce(()=>updateErrors(name, error));\n            delayErrorCallback(props.delayError);\n        } else {\n            clearTimeout(timer);\n            delayErrorCallback = null;\n            error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n        }\n        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {\n            const updatedFormState = {\n                ...fieldState,\n                ...shouldUpdateValid && isBoolean(isValid) ? {\n                    isValid\n                } : {},\n                errors: _formState.errors,\n                name\n            };\n            _formState = {\n                ..._formState,\n                ...updatedFormState\n            };\n            _subjects.state.next(updatedFormState);\n        }\n        _updateIsValidating(false);\n    };\n    const _executeSchema = async (name)=>_options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));\n    const executeSchemaAndUpdateState = async (names)=>{\n        const { errors } = await _executeSchema(names);\n        if (names) {\n            for (const name of names){\n                const error = get(errors, name);\n                error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n            }\n        } else {\n            _formState.errors = errors;\n        }\n        return errors;\n    };\n    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {\n        valid: true\n    })=>{\n        for(const name in fields){\n            const field = fields[name];\n            if (field) {\n                const { _f, ...fieldValue } = field;\n                if (_f) {\n                    const isFieldArrayRoot = _names.array.has(_f.name);\n                    const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);\n                    if (fieldError[_f.name]) {\n                        context.valid = false;\n                        if (shouldOnlyCheckValid) {\n                            break;\n                        }\n                    }\n                    !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));\n                }\n                fieldValue && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);\n            }\n        }\n        return context.valid;\n    };\n    const _removeUnmounted = ()=>{\n        for (const name of _names.unMount){\n            const field = get(_fields, name);\n            field && (field._f.refs ? field._f.refs.every((ref)=>!live(ref)) : !live(field._f.ref)) && unregister(name);\n        }\n        _names.unMount = new Set();\n    };\n    const _getDirty = (name, data)=>(name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));\n    const _getWatch = (names, defaultValue, isGlobal)=>generateWatchOutput(names, _names, {\n            ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? {\n                [names]: defaultValue\n            } : defaultValue\n        }, isGlobal, defaultValue);\n    const _getFieldArray = (name)=>compact(get(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));\n    const setFieldValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        let fieldValue = value1;\n        if (field) {\n            const fieldReference = field._f;\n            if (fieldReference) {\n                !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value1, fieldReference));\n                fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value1) ? \"\" : value1;\n                if (isMultipleSelect(fieldReference.ref)) {\n                    [\n                        ...fieldReference.ref.options\n                    ].forEach((optionRef)=>optionRef.selected = fieldValue.includes(optionRef.value));\n                } else if (fieldReference.refs) {\n                    if (isCheckBoxInput(fieldReference.ref)) {\n                        fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef)=>(!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data)=>data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);\n                    } else {\n                        fieldReference.refs.forEach((radioRef)=>radioRef.checked = radioRef.value === fieldValue);\n                    }\n                } else if (isFileInput(fieldReference.ref)) {\n                    fieldReference.ref.value = \"\";\n                } else {\n                    fieldReference.ref.value = fieldValue;\n                    if (!fieldReference.ref.type) {\n                        _subjects.values.next({\n                            name,\n                            values: {\n                                ..._formValues\n                            }\n                        });\n                    }\n                }\n            }\n        }\n        (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);\n        options.shouldValidate && trigger(name);\n    };\n    const setValues = (name, value1, options)=>{\n        for(const fieldKey in value1){\n            const fieldValue = value1[fieldKey];\n            const fieldName = `${name}.${fieldKey}`;\n            const field = get(_fields, fieldName);\n            (_names.array.has(name) || !isPrimitive(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);\n        }\n    };\n    const setValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        const isFieldArray = _names.array.has(name);\n        const cloneValue = cloneObject(value1);\n        set(_formValues, name, cloneValue);\n        if (isFieldArray) {\n            _subjects.array.next({\n                name,\n                values: {\n                    ..._formValues\n                }\n            });\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {\n                _subjects.state.next({\n                    name,\n                    dirtyFields: getDirtyFields(_defaultValues, _formValues),\n                    isDirty: _getDirty(name, cloneValue)\n                });\n            }\n        } else {\n            field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);\n        }\n        isWatched(name, _names) && _subjects.state.next({\n            ..._formState\n        });\n        _subjects.values.next({\n            name,\n            values: {\n                ..._formValues\n            }\n        });\n        !_state.mount && flushRootRender();\n    };\n    const onChange = async (event)=>{\n        const target = event.target;\n        let name = target.name;\n        let isFieldValueUpdated = true;\n        const field = get(_fields, name);\n        const getCurrentFieldValue = ()=>target.type ? getFieldValue(field._f) : getEventValue(event);\n        const _updateIsFieldValueUpdated = (fieldValue)=>{\n            isFieldValueUpdated = Number.isNaN(fieldValue) || fieldValue === get(_formValues, name, fieldValue);\n        };\n        if (field) {\n            let error;\n            let isValid;\n            const fieldValue = getCurrentFieldValue();\n            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;\n            const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);\n            const watched = isWatched(name, _names, isBlurEvent);\n            set(_formValues, name, fieldValue);\n            if (isBlurEvent) {\n                field._f.onBlur && field._f.onBlur(event);\n                delayErrorCallback && delayErrorCallback(0);\n            } else if (field._f.onChange) {\n                field._f.onChange(event);\n            }\n            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);\n            const shouldRender = !isEmptyObject(fieldState) || watched;\n            !isBlurEvent && _subjects.values.next({\n                name,\n                type: event.type,\n                values: {\n                    ..._formValues\n                }\n            });\n            if (shouldSkipValidation) {\n                _proxyFormState.isValid && _updateValid();\n                return shouldRender && _subjects.state.next({\n                    name,\n                    ...watched ? {} : fieldState\n                });\n            }\n            !isBlurEvent && watched && _subjects.state.next({\n                ..._formState\n            });\n            _updateIsValidating(true);\n            if (_options.resolver) {\n                const { errors } = await _executeSchema([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);\n                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);\n                    error = errorLookupResult.error;\n                    name = errorLookupResult.name;\n                    isValid = isEmptyObject(errors);\n                }\n            } else {\n                error = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    if (error) {\n                        isValid = false;\n                    } else if (_proxyFormState.isValid) {\n                        isValid = await executeBuiltInValidation(_fields, true);\n                    }\n                }\n            }\n            if (isFieldValueUpdated) {\n                field._f.deps && trigger(field._f.deps);\n                shouldRenderByError(name, isValid, error, fieldState);\n            }\n        }\n    };\n    const _focusInput = (ref, key)=>{\n        if (get(_formState.errors, key) && ref.focus) {\n            ref.focus();\n            return 1;\n        }\n        return;\n    };\n    const trigger = async (name, options = {})=>{\n        let isValid;\n        let validationResult;\n        const fieldNames = convertToArrayPayload(name);\n        _updateIsValidating(true);\n        if (_options.resolver) {\n            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);\n            isValid = isEmptyObject(errors);\n            validationResult = name ? !fieldNames.some((name)=>get(errors, name)) : isValid;\n        } else if (name) {\n            validationResult = (await Promise.all(fieldNames.map(async (fieldName)=>{\n                const field = get(_fields, fieldName);\n                return await executeBuiltInValidation(field && field._f ? {\n                    [fieldName]: field\n                } : field);\n            }))).every(Boolean);\n            !(!validationResult && !_formState.isValid) && _updateValid();\n        } else {\n            validationResult = isValid = await executeBuiltInValidation(_fields);\n        }\n        _subjects.state.next({\n            ...!isString(name) || _proxyFormState.isValid && isValid !== _formState.isValid ? {} : {\n                name\n            },\n            ..._options.resolver || !name ? {\n                isValid\n            } : {},\n            errors: _formState.errors,\n            isValidating: false\n        });\n        options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);\n        return validationResult;\n    };\n    const getValues = (fieldNames)=>{\n        const values = {\n            ..._defaultValues,\n            ..._state.mount ? _formValues : {}\n        };\n        return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name)=>get(values, name));\n    };\n    const getFieldState = (name, formState)=>({\n            invalid: !!get((formState || _formState).errors, name),\n            isDirty: !!get((formState || _formState).dirtyFields, name),\n            isTouched: !!get((formState || _formState).touchedFields, name),\n            error: get((formState || _formState).errors, name)\n        });\n    const clearErrors = (name)=>{\n        name && convertToArrayPayload(name).forEach((inputName)=>unset(_formState.errors, inputName));\n        _subjects.state.next({\n            errors: name ? _formState.errors : {}\n        });\n    };\n    const setError = (name, error, options)=>{\n        const ref = (get(_fields, name, {\n            _f: {}\n        })._f || {}).ref;\n        set(_formState.errors, name, {\n            ...error,\n            ref\n        });\n        _subjects.state.next({\n            name,\n            errors: _formState.errors,\n            isValid: false\n        });\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\n    };\n    const watch = (name, defaultValue)=>isFunction(name) ? _subjects.values.subscribe({\n            next: (payload)=>name(_getWatch(undefined, defaultValue), payload)\n        }) : _getWatch(name, defaultValue, true);\n    const unregister = (name, options = {})=>{\n        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount){\n            _names.mount.delete(fieldName);\n            _names.array.delete(fieldName);\n            if (!options.keepValue) {\n                unset(_fields, fieldName);\n                unset(_formValues, fieldName);\n            }\n            !options.keepError && unset(_formState.errors, fieldName);\n            !options.keepDirty && unset(_formState.dirtyFields, fieldName);\n            !options.keepTouched && unset(_formState.touchedFields, fieldName);\n            !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);\n        }\n        _subjects.values.next({\n            values: {\n                ..._formValues\n            }\n        });\n        _subjects.state.next({\n            ..._formState,\n            ...!options.keepDirty ? {} : {\n                isDirty: _getDirty()\n            }\n        });\n        !options.keepIsValid && _updateValid();\n    };\n    const _updateDisabledField = ({ disabled, name, field, fields, value: value1 })=>{\n        if (isBoolean(disabled)) {\n            const inputValue = disabled ? undefined : isUndefined(value1) ? getFieldValue(field ? field._f : get(fields, name)._f) : value1;\n            set(_formValues, name, inputValue);\n            updateTouchAndDirty(name, inputValue, false, false, true);\n        }\n    };\n    const register = (name, options = {})=>{\n        let field = get(_fields, name);\n        const disabledIsDefined = isBoolean(options.disabled);\n        set(_fields, name, {\n            ...field || {},\n            _f: {\n                ...field && field._f ? field._f : {\n                    ref: {\n                        name\n                    }\n                },\n                name,\n                mount: true,\n                ...options\n            }\n        });\n        _names.mount.add(name);\n        if (field) {\n            _updateDisabledField({\n                field,\n                disabled: options.disabled,\n                name\n            });\n        } else {\n            updateValidAndValue(name, true, options.value);\n        }\n        return {\n            ...disabledIsDefined ? {\n                disabled: options.disabled\n            } : {},\n            ..._options.progressive ? {\n                required: !!options.required,\n                min: getRuleValue(options.min),\n                max: getRuleValue(options.max),\n                minLength: getRuleValue(options.minLength),\n                maxLength: getRuleValue(options.maxLength),\n                pattern: getRuleValue(options.pattern)\n            } : {},\n            name,\n            onChange,\n            onBlur: onChange,\n            ref: (ref)=>{\n                if (ref) {\n                    register(name, options);\n                    field = get(_fields, name);\n                    const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll(\"input,select,textarea\")[0] || ref : ref : ref;\n                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);\n                    const refs = field._f.refs || [];\n                    if (radioOrCheckbox ? refs.find((option)=>option === fieldRef) : fieldRef === field._f.ref) {\n                        return;\n                    }\n                    set(_fields, name, {\n                        _f: {\n                            ...field._f,\n                            ...radioOrCheckbox ? {\n                                refs: [\n                                    ...refs.filter(live),\n                                    fieldRef,\n                                    ...Array.isArray(get(_defaultValues, name)) ? [\n                                        {}\n                                    ] : []\n                                ],\n                                ref: {\n                                    type: fieldRef.type,\n                                    name\n                                }\n                            } : {\n                                ref: fieldRef\n                            }\n                        }\n                    });\n                    updateValidAndValue(name, false, undefined, fieldRef);\n                } else {\n                    field = get(_fields, name, {});\n                    if (field._f) {\n                        field._f.mount = false;\n                    }\n                    (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);\n                }\n            }\n        };\n    };\n    const _focusError = ()=>_options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);\n    const _disableForm = (disabled)=>{\n        if (isBoolean(disabled)) {\n            _subjects.state.next({\n                disabled\n            });\n            iterateFieldsByAction(_fields, (ref)=>{\n                ref.disabled = disabled;\n            }, 0, false);\n        }\n    };\n    const handleSubmit = (onValid, onInvalid)=>async (e)=>{\n            if (e) {\n                e.preventDefault && e.preventDefault();\n                e.persist && e.persist();\n            }\n            let fieldValues = cloneObject(_formValues);\n            _subjects.state.next({\n                isSubmitting: true\n            });\n            if (_options.resolver) {\n                const { errors, values } = await _executeSchema();\n                _formState.errors = errors;\n                fieldValues = values;\n            } else {\n                await executeBuiltInValidation(_fields);\n            }\n            unset(_formState.errors, \"root\");\n            if (isEmptyObject(_formState.errors)) {\n                _subjects.state.next({\n                    errors: {}\n                });\n                await onValid(fieldValues, e);\n            } else {\n                if (onInvalid) {\n                    await onInvalid({\n                        ..._formState.errors\n                    }, e);\n                }\n                _focusError();\n                setTimeout(_focusError);\n            }\n            _subjects.state.next({\n                isSubmitted: true,\n                isSubmitting: false,\n                isSubmitSuccessful: isEmptyObject(_formState.errors),\n                submitCount: _formState.submitCount + 1,\n                errors: _formState.errors\n            });\n        };\n    const resetField = (name, options = {})=>{\n        if (get(_fields, name)) {\n            if (isUndefined(options.defaultValue)) {\n                setValue(name, get(_defaultValues, name));\n            } else {\n                setValue(name, options.defaultValue);\n                set(_defaultValues, name, options.defaultValue);\n            }\n            if (!options.keepTouched) {\n                unset(_formState.touchedFields, name);\n            }\n            if (!options.keepDirty) {\n                unset(_formState.dirtyFields, name);\n                _formState.isDirty = options.defaultValue ? _getDirty(name, get(_defaultValues, name)) : _getDirty();\n            }\n            if (!options.keepError) {\n                unset(_formState.errors, name);\n                _proxyFormState.isValid && _updateValid();\n            }\n            _subjects.state.next({\n                ..._formState\n            });\n        }\n    };\n    const _reset = (formValues, keepStateOptions = {})=>{\n        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;\n        const cloneUpdatedValues = cloneObject(updatedValues);\n        const values = formValues && !isEmptyObject(formValues) ? cloneUpdatedValues : _defaultValues;\n        if (!keepStateOptions.keepDefaultValues) {\n            _defaultValues = updatedValues;\n        }\n        if (!keepStateOptions.keepValues) {\n            if (keepStateOptions.keepDirtyValues || shouldCaptureDirtyFields) {\n                for (const fieldName of _names.mount){\n                    get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));\n                }\n            } else {\n                if (isWeb && isUndefined(formValues)) {\n                    for (const name of _names.mount){\n                        const field = get(_fields, name);\n                        if (field && field._f) {\n                            const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n                            if (isHTMLElement(fieldReference)) {\n                                const form = fieldReference.closest(\"form\");\n                                if (form) {\n                                    form.reset();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                _fields = {};\n            }\n            _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);\n            _subjects.array.next({\n                values: {\n                    ...values\n                }\n            });\n            _subjects.values.next({\n                values: {\n                    ...values\n                }\n            });\n        }\n        _names = {\n            mount: new Set(),\n            unMount: new Set(),\n            array: new Set(),\n            watch: new Set(),\n            watchAll: false,\n            focus: \"\"\n        };\n        !_state.mount && flushRootRender();\n        _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid;\n        _state.watch = !!props.shouldUnregister;\n        _subjects.state.next({\n            submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,\n            isDirty: keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),\n            isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,\n            dirtyFields: keepStateOptions.keepDirtyValues ? _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : {},\n            touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\n            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,\n            isSubmitting: false\n        });\n    };\n    const reset = (formValues, keepStateOptions)=>_reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);\n    const setFocus = (name, options = {})=>{\n        const field = get(_fields, name);\n        const fieldReference = field && field._f;\n        if (fieldReference) {\n            const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;\n            if (fieldRef.focus) {\n                fieldRef.focus();\n                options.shouldSelect && fieldRef.select();\n            }\n        }\n    };\n    const _updateFormState = (updatedFormState)=>{\n        _formState = {\n            ..._formState,\n            ...updatedFormState\n        };\n    };\n    const _resetDefaultValues = ()=>isFunction(_options.defaultValues) && _options.defaultValues().then((values)=>{\n            reset(values, _options.resetOptions);\n            _subjects.state.next({\n                isLoading: false\n            });\n        });\n    return {\n        control: {\n            register,\n            unregister,\n            getFieldState,\n            handleSubmit,\n            setError,\n            _executeSchema,\n            _getWatch,\n            _getDirty,\n            _updateValid,\n            _removeUnmounted,\n            _updateFieldArray,\n            _updateDisabledField,\n            _getFieldArray,\n            _reset,\n            _resetDefaultValues,\n            _updateFormState,\n            _disableForm,\n            _subjects,\n            _proxyFormState,\n            get _fields () {\n                return _fields;\n            },\n            get _formValues () {\n                return _formValues;\n            },\n            get _state () {\n                return _state;\n            },\n            set _state (value){\n                _state = value;\n            },\n            get _defaultValues () {\n                return _defaultValues;\n            },\n            get _names () {\n                return _names;\n            },\n            set _names (value){\n                _names = value;\n            },\n            get _formState () {\n                return _formState;\n            },\n            set _formState (value){\n                _formState = value;\n            },\n            get _options () {\n                return _options;\n            },\n            set _options (value){\n                _options = {\n                    ..._options,\n                    ...value\n                };\n            }\n        },\n        trigger,\n        register,\n        handleSubmit,\n        watch,\n        setValue,\n        getValues,\n        reset,\n        resetField,\n        clearErrors,\n        unregister,\n        setError,\n        setFocus,\n        getFieldState\n    };\n}\n/**\n * Custom hook to manage the entire form.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)\n *\n * @param props - form configuration and validation parameters.\n *\n * @returns methods - individual functions to manage the form state. {@link UseFormReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, watch, formState: { errors } } = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   console.log(watch(\"example\"));\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input defaultValue=\"test\" {...register(\"example\")} />\n *       <input {...register(\"exampleRequired\", { required: true })} />\n *       {errors.exampleRequired && <span>This field is required</span>}\n *       <button>Submit</button>\n *     </form>\n *   );\n * }\n * ```\n */ function useForm(props = {}) {\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const _values = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isDirty: false,\n        isValidating: false,\n        isLoading: isFunction(props.defaultValues),\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        submitCount: 0,\n        dirtyFields: {},\n        touchedFields: {},\n        errors: {},\n        disabled: false,\n        defaultValues: isFunction(props.defaultValues) ? undefined : props.defaultValues\n    });\n    if (!_formControl.current) {\n        _formControl.current = {\n            ...createFormControl(props, ()=>updateFormState((formState)=>({\n                        ...formState\n                    }))),\n            formState\n        };\n    }\n    const control = _formControl.current.control;\n    control._options = props;\n    useSubscribe({\n        subject: control._subjects.state,\n        next: (value1)=>{\n            if (shouldRenderFormState(value1, control._proxyFormState, control._updateFormState, true)) {\n                updateFormState({\n                    ...control._formState\n                });\n            }\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._disableForm(props.disabled), [\n        control,\n        props.disabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (control._proxyFormState.isDirty) {\n            const isDirty = control._getDirty();\n            if (isDirty !== formState.isDirty) {\n                control._subjects.state.next({\n                    isDirty\n                });\n            }\n        }\n    }, [\n        control,\n        formState.isDirty\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.values && !deepEqual(props.values, _values.current)) {\n            control._reset(props.values, control._options.resetOptions);\n            _values.current = props.values;\n        } else {\n            control._resetDefaultValues();\n        }\n    }, [\n        props.values,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!control._state.mount) {\n            control._updateValid();\n            control._state.mount = true;\n        }\n        if (control._state.watch) {\n            control._state.watch = false;\n            control._subjects.state.next({\n                ...control._formState\n            });\n        }\n        control._removeUnmounted();\n    });\n    _formControl.current.formState = getProxyFormState(formState, control);\n    return _formControl.current;\n}\n //# sourceMappingURL=index.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBRTFCLElBQUlDLGtCQUFrQixDQUFDQyxVQUFZQSxRQUFRQyxJQUFJLEtBQUs7QUFFcEQsSUFBSUMsZUFBZSxDQUFDQyxTQUFVQSxrQkFBaUJDO0FBRS9DLElBQUlDLG9CQUFvQixDQUFDRixTQUFVQSxVQUFTO0FBRTVDLE1BQU1HLGVBQWUsQ0FBQ0gsU0FBVSxPQUFPQSxXQUFVO0FBQ2pELElBQUlJLFdBQVcsQ0FBQ0osU0FBVSxDQUFDRSxrQkFBa0JGLFdBQ3pDLENBQUNLLE1BQU1DLE9BQU8sQ0FBQ04sV0FDZkcsYUFBYUgsV0FDYixDQUFDRCxhQUFhQztBQUVsQixJQUFJTyxnQkFBZ0IsQ0FBQ0MsUUFBVUosU0FBU0ksVUFBVUEsTUFBTUMsTUFBTSxHQUN4RGIsZ0JBQWdCWSxNQUFNQyxNQUFNLElBQ3hCRCxNQUFNQyxNQUFNLENBQUNDLE9BQU8sR0FDcEJGLE1BQU1DLE1BQU0sQ0FBQ1QsS0FBSyxHQUN0QlE7QUFFTixJQUFJRyxvQkFBb0IsQ0FBQ0MsT0FBU0EsS0FBS0MsU0FBUyxDQUFDLEdBQUdELEtBQUtFLE1BQU0sQ0FBQyxtQkFBbUJGO0FBRW5GLElBQUlHLHFCQUFxQixDQUFDQyxPQUFPSixPQUFTSSxNQUFNQyxHQUFHLENBQUNOLGtCQUFrQkM7QUFFdEUsSUFBSU0sZ0JBQWdCLENBQUNDO0lBQ2pCLE1BQU1DLGdCQUFnQkQsV0FBV0UsV0FBVyxJQUFJRixXQUFXRSxXQUFXLENBQUNDLFNBQVM7SUFDaEYsT0FBUWxCLFNBQVNnQixrQkFBa0JBLGNBQWNHLGNBQWMsQ0FBQztBQUNwRTtBQUVBLElBQUlDLFFBQVEsTUFDc0IsSUFDOUIsQ0FBb0I7QUFFeEIsU0FBU0ksWUFBWUMsSUFBSTtJQUNyQixJQUFJQztJQUNKLE1BQU14QixVQUFVRCxNQUFNQyxPQUFPLENBQUN1QjtJQUM5QixJ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QUFHaEMsUUFBUXFDLFVBQVU7WUFBQztRQUN6RDtRQUNBckMsUUFBUW1FLGdCQUFnQjtJQUM1QjtJQUNBc1ksYUFBYS9hLE9BQU8sQ0FBQzNCLFNBQVMsR0FBR0Qsa0JBQWtCQyxXQUFXQztJQUM5RCxPQUFPeWMsYUFBYS9hLE9BQU87QUFDL0I7QUFFaUosQ0FDakosc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGhlLWlucXVpcnktcm9vbS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ob29rLWZvcm0vZGlzdC9pbmRleC5lc20ubWpzPzlkYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxudmFyIGlzQ2hlY2tCb3hJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdjaGVja2JveCc7XG5cbnZhciBpc0RhdGVPYmplY3QgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcblxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gKHZhbHVlKSA9PiB2YWx1ZSA9PSBudWxsO1xuXG5jb25zdCBpc09iamVjdFR5cGUgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG52YXIgaXNPYmplY3QgPSAodmFsdWUpID0+ICFpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgJiZcbiAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICBpc09iamVjdFR5cGUodmFsdWUpICYmXG4gICAgIWlzRGF0ZU9iamVjdCh2YWx1ZSk7XG5cbnZhciBnZXRFdmVudFZhbHVlID0gKGV2ZW50KSA9PiBpc09iamVjdChldmVudCkgJiYgZXZlbnQudGFyZ2V0XG4gICAgPyBpc0NoZWNrQm94SW5wdXQoZXZlbnQudGFyZ2V0KVxuICAgICAgICA/IGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgIDogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgOiBldmVudDtcblxudmFyIGdldE5vZGVQYXJlbnROYW1lID0gKG5hbWUpID0+IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUuc2VhcmNoKC9cXC5cXGQrKFxcLnwkKS8pKSB8fCBuYW1lO1xuXG52YXIgaXNOYW1lSW5GaWVsZEFycmF5ID0gKG5hbWVzLCBuYW1lKSA9PiBuYW1lcy5oYXMoZ2V0Tm9kZVBhcmVudE5hbWUobmFtZSkpO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9ICh0ZW1wT2JqZWN0KSA9PiB7XG4gICAgY29uc3QgcHJvdG90eXBlQ29weSA9IHRlbXBPYmplY3QuY29uc3RydWN0b3IgJiYgdGVtcE9iamVjdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIChpc09iamVjdChwcm90b3R5cGVDb3B5KSAmJiBwcm90b3R5cGVDb3B5Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykpO1xufTtcblxudmFyIGlzV2ViID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LkhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGNsb25lT2JqZWN0KGRhdGEpIHtcbiAgICBsZXQgY29weTtcbiAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShkYXRhKTtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgY29weSA9IG5ldyBEYXRlKGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGNvcHkgPSBuZXcgU2V0KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICghKGlzV2ViICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBkYXRhIGluc3RhbmNlb2YgRmlsZUxpc3QpKSAmJlxuICAgICAgICAoaXNBcnJheSB8fCBpc09iamVjdChkYXRhKSkpIHtcbiAgICAgICAgY29weSA9IGlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICBpZiAoIWlzQXJyYXkgJiYgIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvcHkgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVtrZXldID0gY2xvbmVPYmplY3QoZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cblxudmFyIGNvbXBhY3QgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuZmlsdGVyKEJvb2xlYW4pIDogW107XG5cbnZhciBpc1VuZGVmaW5lZCA9ICh2YWwpID0+IHZhbCA9PT0gdW5kZWZpbmVkO1xuXG52YXIgZ2V0ID0gKG9iaiwgcGF0aCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgaWYgKCFwYXRoIHx8ICFpc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhY3QocGF0aC5zcGxpdCgvWyxbXFxdLl0rPy8pKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiBpc051bGxPclVuZGVmaW5lZChyZXN1bHQpID8gcmVzdWx0IDogcmVzdWx0W2tleV0sIG9iaik7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHJlc3VsdCkgfHwgcmVzdWx0ID09PSBvYmpcbiAgICAgICAgPyBpc1VuZGVmaW5lZChvYmpbcGF0aF0pXG4gICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgOiBvYmpbcGF0aF1cbiAgICAgICAgOiByZXN1bHQ7XG59O1xuXG52YXIgaXNCb29sZWFuID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcblxuY29uc3QgRVZFTlRTID0ge1xuICAgIEJMVVI6ICdibHVyJyxcbiAgICBGT0NVU19PVVQ6ICdmb2N1c291dCcsXG4gICAgQ0hBTkdFOiAnY2hhbmdlJyxcbn07XG5jb25zdCBWQUxJREFUSU9OX01PREUgPSB7XG4gICAgb25CbHVyOiAnb25CbHVyJyxcbiAgICBvbkNoYW5nZTogJ29uQ2hhbmdlJyxcbiAgICBvblN1Ym1pdDogJ29uU3VibWl0JyxcbiAgICBvblRvdWNoZWQ6ICdvblRvdWNoZWQnLFxuICAgIGFsbDogJ2FsbCcsXG59O1xuY29uc3QgSU5QVVRfVkFMSURBVElPTl9SVUxFUyA9IHtcbiAgICBtYXg6ICdtYXgnLFxuICAgIG1pbjogJ21pbicsXG4gICAgbWF4TGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgICBtaW5MZW5ndGg6ICdtaW5MZW5ndGgnLFxuICAgIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgICB2YWxpZGF0ZTogJ3ZhbGlkYXRlJyxcbn07XG5cbmNvbnN0IEhvb2tGb3JtQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBhY2Nlc3MgdGhlIGZvcm0gY29udGV4dC4gdXNlRm9ybUNvbnRleHQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBkZWVwbHkgbmVzdGVkIHN0cnVjdHVyZXMsIHdoZXJlIGl0IHdvdWxkIGJlY29tZSBpbmNvbnZlbmllbnQgdG8gcGFzcyB0aGUgY29udGV4dCBhcyBhIHByb3AuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgRm9ybVByb3ZpZGVyfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybWNvbnRleHQpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny1mb3JtLWNvbnRleHQteXR1ZGkpXG4gKlxuICogQHJldHVybnMgcmV0dXJuIGFsbCB1c2VGb3JtIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm1Qcm92aWRlciB7Li4ubWV0aG9kc30gPlxuICogICAgICAgPGZvcm0gb25TdWJtaXQ9e21ldGhvZHMuaGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICAgIDxOZXN0ZWRJbnB1dCAvPlxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgICA8L2Zvcm0+XG4gKiAgICAgPC9Gb3JtUHJvdmlkZXI+XG4gKiAgICk7XG4gKiB9XG4gKlxuICogIGZ1bmN0aW9uIE5lc3RlZElucHV0KCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB1c2VGb3JtQ29udGV4dCgpOyAvLyByZXRyaWV2ZSBhbGwgaG9vayBtZXRob2RzXG4gKiAgIHJldHVybiA8aW5wdXQgey4uLnJlZ2lzdGVyKFwidGVzdFwiKX0gLz47XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgdXNlRm9ybUNvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEhvb2tGb3JtQ29udGV4dCk7XG4vKipcbiAqIEEgcHJvdmlkZXIgY29tcG9uZW50IHRoYXQgcHJvcGFnYXRlcyB0aGUgYHVzZUZvcm1gIG1ldGhvZHMgdG8gYWxsIGNoaWxkcmVuIGNvbXBvbmVudHMgdmlhIFtSZWFjdCBDb250ZXh0XShodHRwczovL3JlYWN0anMub3JnL2RvY3MvY29udGV4dC5odG1sKSBBUEkuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgdXNlRm9ybUNvbnRleHR9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtY29udGV4dCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LWZvcm0tY29udGV4dC15dHVkaSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBhbGwgdXNlRm9ybSBtZXRob2RzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBtZXRob2RzID0gdXNlRm9ybSgpO1xuICogICBjb25zdCBvblN1Ym1pdCA9IGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxGb3JtUHJvdmlkZXIgey4uLm1ldGhvZHN9ID5cbiAqICAgICAgIDxmb3JtIG9uU3VibWl0PXttZXRob2RzLmhhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgICA8TmVzdGVkSW5wdXQgLz5cbiAqICAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgICAgPC9mb3JtPlxuICogICAgIDwvRm9ybVByb3ZpZGVyPlxuICogICApO1xuICogfVxuICpcbiAqICBmdW5jdGlvbiBOZXN0ZWRJbnB1dCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciB9ID0gdXNlRm9ybUNvbnRleHQoKTsgLy8gcmV0cmlldmUgYWxsIGhvb2sgbWV0aG9kc1xuICogICByZXR1cm4gPGlucHV0IHsuLi5yZWdpc3RlcihcInRlc3RcIil9IC8+O1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IEZvcm1Qcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLmRhdGEgfSA9IHByb3BzO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChIb29rRm9ybUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGRhdGEgfSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBnZXRQcm94eUZvcm1TdGF0ZSA9IChmb3JtU3RhdGUsIGNvbnRyb2wsIGxvY2FsUHJveHlGb3JtU3RhdGUsIGlzUm9vdCA9IHRydWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZXM6IGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtU3RhdGUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfa2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSAhPT0gVkFMSURBVElPTl9NT0RFLmFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSA9ICFpc1Jvb3QgfHwgVkFMSURBVElPTl9NT0RFLmFsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxQcm94eUZvcm1TdGF0ZSAmJiAobG9jYWxQcm94eUZvcm1TdGF0ZVtfa2V5XSA9IHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtU3RhdGVbX2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBpc0VtcHR5T2JqZWN0ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG5cbnZhciBzaG91bGRSZW5kZXJGb3JtU3RhdGUgPSAoZm9ybVN0YXRlRGF0YSwgX3Byb3h5Rm9ybVN0YXRlLCB1cGRhdGVGb3JtU3RhdGUsIGlzUm9vdCkgPT4ge1xuICAgIHVwZGF0ZUZvcm1TdGF0ZShmb3JtU3RhdGVEYXRhKTtcbiAgICBjb25zdCB7IG5hbWUsIC4uLmZvcm1TdGF0ZSB9ID0gZm9ybVN0YXRlRGF0YTtcbiAgICByZXR1cm4gKGlzRW1wdHlPYmplY3QoZm9ybVN0YXRlKSB8fFxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmxlbmd0aCA+PSBPYmplY3Qua2V5cyhfcHJveHlGb3JtU3RhdGUpLmxlbmd0aCB8fFxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmZpbmQoKGtleSkgPT4gX3Byb3h5Rm9ybVN0YXRlW2tleV0gPT09XG4gICAgICAgICAgICAoIWlzUm9vdCB8fCBWQUxJREFUSU9OX01PREUuYWxsKSkpO1xufTtcblxudmFyIGNvbnZlcnRUb0FycmF5UGF5bG9hZCA9ICh2YWx1ZSkgPT4gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcblxudmFyIHNob3VsZFN1YnNjcmliZUJ5TmFtZSA9IChuYW1lLCBzaWduYWxOYW1lLCBleGFjdCkgPT4gIW5hbWUgfHxcbiAgICAhc2lnbmFsTmFtZSB8fFxuICAgIG5hbWUgPT09IHNpZ25hbE5hbWUgfHxcbiAgICBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkuc29tZSgoY3VycmVudE5hbWUpID0+IGN1cnJlbnROYW1lICYmXG4gICAgICAgIChleGFjdFxuICAgICAgICAgICAgPyBjdXJyZW50TmFtZSA9PT0gc2lnbmFsTmFtZVxuICAgICAgICAgICAgOiBjdXJyZW50TmFtZS5zdGFydHNXaXRoKHNpZ25hbE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgc2lnbmFsTmFtZS5zdGFydHNXaXRoKGN1cnJlbnROYW1lKSkpO1xuXG5mdW5jdGlvbiB1c2VTdWJzY3JpYmUocHJvcHMpIHtcbiAgICBjb25zdCBfcHJvcHMgPSBSZWFjdC51c2VSZWYocHJvcHMpO1xuICAgIF9wcm9wcy5jdXJyZW50ID0gcHJvcHM7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gIXByb3BzLmRpc2FibGVkICYmXG4gICAgICAgICAgICBfcHJvcHMuY3VycmVudC5zdWJqZWN0ICYmXG4gICAgICAgICAgICBfcHJvcHMuY3VycmVudC5zdWJqZWN0LnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogX3Byb3BzLmN1cnJlbnQubmV4dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uICYmIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtwcm9wcy5kaXNhYmxlZF0pO1xufVxuXG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBzdWJzY3JpYmUgdG8gZWFjaCBmb3JtIHN0YXRlLCBhbmQgaXNvbGF0ZSB0aGUgcmUtcmVuZGVyIGF0IHRoZSBjdXN0b20gaG9vayBsZXZlbC4gSXQgaGFzIGl0cyBzY29wZSBpbiB0ZXJtcyBvZiBmb3JtIHN0YXRlIHN1YnNjcmlwdGlvbiwgc28gaXQgd291bGQgbm90IGFmZmVjdCBvdGhlciB1c2VGb3JtU3RhdGUgYW5kIHVzZUZvcm0uIFVzaW5nIHRoaXMgaG9vayBjYW4gcmVkdWNlIHRoZSByZS1yZW5kZXIgaW1wYWN0IG9uIGxhcmdlIGFuZCBjb21wbGV4IGZvcm0gYXBwbGljYXRpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm1zdGF0ZSkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdXNlZm9ybXN0YXRlLTc1eGx5KVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIGluY2x1ZGUgb3B0aW9ucyBvbiBzcGVjaWZ5IGZpZWxkcyB0byBzdWJzY3JpYmUuIHtAbGluayBVc2VGb3JtU3RhdGVSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBoYW5kbGVTdWJtaXQsIGNvbnRyb2wgfSA9IHVzZUZvcm0oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICBmaXJzdE5hbWU6IFwiZmlyc3ROYW1lXCJcbiAqICAgfX0pO1xuICogICBjb25zdCB7IGRpcnR5RmllbGRzIH0gPSB1c2VGb3JtU3RhdGUoe1xuICogICAgIGNvbnRyb2xcbiAqICAgfSk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gKGRhdGEpID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwiZmlyc3ROYW1lXCIpfSBwbGFjZWhvbGRlcj1cIkZpcnN0IE5hbWVcIiAvPlxuICogICAgICAge2RpcnR5RmllbGRzLmZpcnN0TmFtZSAmJiA8cD5GaWVsZCBpcyBkaXJ0eS48L3A+fVxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGb3JtU3RhdGUocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIGRpc2FibGVkLCBuYW1lLCBleGFjdCB9ID0gcHJvcHMgfHwge307XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGNvbnRyb2wuX2Zvcm1TdGF0ZSk7XG4gICAgY29uc3QgX21vdW50ZWQgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gICAgY29uc3QgX2xvY2FsUHJveHlGb3JtU3RhdGUgPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB0b3VjaGVkRmllbGRzOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yczogZmFsc2UsXG4gICAgfSk7XG4gICAgY29uc3QgX25hbWUgPSBSZWFjdC51c2VSZWYobmFtZSk7XG4gICAgX25hbWUuY3VycmVudCA9IG5hbWU7XG4gICAgdXNlU3Vic2NyaWJlKHtcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIG5leHQ6ICh2YWx1ZSkgPT4gX21vdW50ZWQuY3VycmVudCAmJlxuICAgICAgICAgICAgc2hvdWxkU3Vic2NyaWJlQnlOYW1lKF9uYW1lLmN1cnJlbnQsIHZhbHVlLm5hbWUsIGV4YWN0KSAmJlxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyRm9ybVN0YXRlKHZhbHVlLCBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LCBjb250cm9sLl91cGRhdGVGb3JtU3RhdGUpICYmXG4gICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoe1xuICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBzdWJqZWN0OiBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZSxcbiAgICB9KTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBfbW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudC5pc1ZhbGlkICYmIGNvbnRyb2wuX3VwZGF0ZVZhbGlkKHRydWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgX21vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sIFtjb250cm9sXSk7XG4gICAgcmV0dXJuIGdldFByb3h5Rm9ybVN0YXRlKGZvcm1TdGF0ZSwgY29udHJvbCwgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudCwgZmFsc2UpO1xufVxuXG52YXIgaXNTdHJpbmcgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG5cbnZhciBnZW5lcmF0ZVdhdGNoT3V0cHV0ID0gKG5hbWVzLCBfbmFtZXMsIGZvcm1WYWx1ZXMsIGlzR2xvYmFsLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICBpZiAoaXNTdHJpbmcobmFtZXMpKSB7XG4gICAgICAgIGlzR2xvYmFsICYmIF9uYW1lcy53YXRjaC5hZGQobmFtZXMpO1xuICAgICAgICByZXR1cm4gZ2V0KGZvcm1WYWx1ZXMsIG5hbWVzLCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lcykpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVzLm1hcCgoZmllbGROYW1lKSA9PiAoaXNHbG9iYWwgJiYgX25hbWVzLndhdGNoLmFkZChmaWVsZE5hbWUpLCBnZXQoZm9ybVZhbHVlcywgZmllbGROYW1lKSkpO1xuICAgIH1cbiAgICBpc0dsb2JhbCAmJiAoX25hbWVzLndhdGNoQWxsID0gdHJ1ZSk7XG4gICAgcmV0dXJuIGZvcm1WYWx1ZXM7XG59O1xuXG4vKipcbiAqIEN1c3RvbSBob29rIHRvIHN1YnNjcmliZSB0byBmaWVsZCBjaGFuZ2UgYW5kIGlzb2xhdGUgcmUtcmVuZGVyaW5nIGF0IHRoZSBjb21wb25lbnQgbGV2ZWwuXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2V3YXRjaCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LXRzLXVzZXdhdGNoLWg5aTVlKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IHsgY29udHJvbCB9ID0gdXNlRm9ybSgpO1xuICogY29uc3QgdmFsdWVzID0gdXNlV2F0Y2goe1xuICogICBuYW1lOiBcImZpZWxkTmFtZVwiXG4gKiAgIGNvbnRyb2wsXG4gKiB9KVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZVdhdGNoKHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBuYW1lLCBkZWZhdWx0VmFsdWUsIGRpc2FibGVkLCBleGFjdCwgfSA9IHByb3BzIHx8IHt9O1xuICAgIGNvbnN0IF9uYW1lID0gUmVhY3QudXNlUmVmKG5hbWUpO1xuICAgIF9uYW1lLmN1cnJlbnQgPSBuYW1lO1xuICAgIHVzZVN1YnNjcmliZSh7XG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBzdWJqZWN0OiBjb250cm9sLl9zdWJqZWN0cy52YWx1ZXMsXG4gICAgICAgIG5leHQ6IChmb3JtU3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdWJzY3JpYmVCeU5hbWUoX25hbWUuY3VycmVudCwgZm9ybVN0YXRlLm5hbWUsIGV4YWN0KSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKGNsb25lT2JqZWN0KGdlbmVyYXRlV2F0Y2hPdXRwdXQoX25hbWUuY3VycmVudCwgY29udHJvbC5fbmFtZXMsIGZvcm1TdGF0ZS52YWx1ZXMgfHwgY29udHJvbC5fZm9ybVZhbHVlcywgZmFsc2UsIGRlZmF1bHRWYWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBbdmFsdWUsIHVwZGF0ZVZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKGNvbnRyb2wuX2dldFdhdGNoKG5hbWUsIGRlZmF1bHRWYWx1ZSkpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiBjb250cm9sLl9yZW1vdmVVbm1vdW50ZWQoKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgaXNLZXkgPSAodmFsdWUpID0+IC9eXFx3KiQvLnRlc3QodmFsdWUpO1xuXG52YXIgc3RyaW5nVG9QYXRoID0gKGlucHV0KSA9PiBjb21wYWN0KGlucHV0LnJlcGxhY2UoL1tcInwnXXxcXF0vZywgJycpLnNwbGl0KC9cXC58XFxbLykpO1xuXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IHRlbXBQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgocGF0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gdGVtcFBhdGgubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGVtcFBhdGhbaW5kZXhdO1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgaXNPYmplY3Qob2JqVmFsdWUpIHx8IEFycmF5LmlzQXJyYXkob2JqVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNOYU4oK3RlbXBQYXRoW2luZGV4ICsgMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIEN1c3RvbSBob29rIHRvIHdvcmsgd2l0aCBjb250cm9sbGVkIGNvbXBvbmVudCwgdGhpcyBmdW5jdGlvbiBwcm92aWRlIHlvdSB3aXRoIGJvdGggZm9ybSBhbmQgZmllbGQgbGV2ZWwgc3RhdGUuIFJlLXJlbmRlciBpcyBpc29sYXRlZCBhdCB0aGUgaG9vayBsZXZlbC5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlY29udHJvbGxlcikg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdXNlY29udHJvbGxlci0wbzhweClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB0aGUgcGF0aCBuYW1lIHRvIHRoZSBmb3JtIGZpZWxkIHZhbHVlLCBhbmQgdmFsaWRhdGlvbiBydWxlcy5cbiAqXG4gKiBAcmV0dXJucyBmaWVsZCBwcm9wZXJ0aWVzLCBmaWVsZCBhbmQgZm9ybSBzdGF0ZS4ge0BsaW5rIFVzZUNvbnRyb2xsZXJSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gSW5wdXQocHJvcHMpIHtcbiAqICAgY29uc3QgeyBmaWVsZCwgZmllbGRTdGF0ZSwgZm9ybVN0YXRlIH0gPSB1c2VDb250cm9sbGVyKHByb3BzKTtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPGlucHV0IHsuLi5maWVsZH0gcGxhY2Vob2xkZXI9e3Byb3BzLm5hbWV9IC8+XG4gKiAgICAgICA8cD57ZmllbGRTdGF0ZS5pc1RvdWNoZWQgJiYgXCJUb3VjaGVkXCJ9PC9wPlxuICogICAgICAgPHA+e2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCA/IFwic3VibWl0dGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VDb250cm9sbGVyKHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgeyBuYW1lLCBkaXNhYmxlZCwgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgc2hvdWxkVW5yZWdpc3RlciB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXNBcnJheUZpZWxkID0gaXNOYW1lSW5GaWVsZEFycmF5KGNvbnRyb2wuX25hbWVzLmFycmF5LCBuYW1lKTtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZVdhdGNoKHtcbiAgICAgICAgY29udHJvbCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSwgZ2V0KGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIHByb3BzLmRlZmF1bHRWYWx1ZSkpLFxuICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICB9KTtcbiAgICBjb25zdCBmb3JtU3RhdGUgPSB1c2VGb3JtU3RhdGUoe1xuICAgICAgICBjb250cm9sLFxuICAgICAgICBuYW1lLFxuICAgIH0pO1xuICAgIGNvbnN0IF9yZWdpc3RlclByb3BzID0gUmVhY3QudXNlUmVmKGNvbnRyb2wucmVnaXN0ZXIobmFtZSwge1xuICAgICAgICAuLi5wcm9wcy5ydWxlcyxcbiAgICAgICAgdmFsdWUsXG4gICAgfSkpO1xuICAgIF9yZWdpc3RlclByb3BzLmN1cnJlbnQgPSBjb250cm9sLnJlZ2lzdGVyKG5hbWUsIHByb3BzLnJ1bGVzKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBfc2hvdWxkVW5yZWdpc3RlckZpZWxkID0gY29udHJvbC5fb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IHNob3VsZFVucmVnaXN0ZXI7XG4gICAgICAgIGNvbnN0IHVwZGF0ZU1vdW50ZWQgPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5tb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB1cGRhdGVNb3VudGVkKG5hbWUsIHRydWUpO1xuICAgICAgICBpZiAoX3Nob3VsZFVucmVnaXN0ZXJGaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjbG9uZU9iamVjdChnZXQoY29udHJvbC5fb3B0aW9ucy5kZWZhdWx0VmFsdWVzLCBuYW1lKSk7XG4gICAgICAgICAgICBzZXQoY29udHJvbC5fZGVmYXVsdFZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBzZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAoaXNBcnJheUZpZWxkXG4gICAgICAgICAgICAgICAgPyBfc2hvdWxkVW5yZWdpc3RlckZpZWxkICYmICFjb250cm9sLl9zdGF0ZS5hY3Rpb25cbiAgICAgICAgICAgICAgICA6IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQpXG4gICAgICAgICAgICAgICAgPyBjb250cm9sLnVucmVnaXN0ZXIobmFtZSlcbiAgICAgICAgICAgICAgICA6IHVwZGF0ZU1vdW50ZWQobmFtZSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtuYW1lLCBjb250cm9sLCBpc0FycmF5RmllbGQsIHNob3VsZFVucmVnaXN0ZXJdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3VwZGF0ZURpc2FibGVkRmllbGQoe1xuICAgICAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgICAgIGZpZWxkczogY29udHJvbC5fZmllbGRzLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpLl9mLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGlzYWJsZWQsIG5hbWUsIGNvbnRyb2xdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZDoge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgLi4uKGlzQm9vbGVhbihkaXNhYmxlZCkgfHwgaXNCb29sZWFuKGZvcm1TdGF0ZS5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICA/IHsgZGlzYWJsZWQ6IGZvcm1TdGF0ZS5kaXNhYmxlZCB8fCBkaXNhYmxlZCB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICBvbkNoYW5nZTogUmVhY3QudXNlQ2FsbGJhY2soKGV2ZW50KSA9PiBfcmVnaXN0ZXJQcm9wcy5jdXJyZW50Lm9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldEV2ZW50VmFsdWUoZXZlbnQpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHlwZTogRVZFTlRTLkNIQU5HRSxcbiAgICAgICAgICAgIH0pLCBbbmFtZV0pLFxuICAgICAgICAgICAgb25CbHVyOiBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBfcmVnaXN0ZXJQcm9wcy5jdXJyZW50Lm9uQmx1cih7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlOiBFVkVOVFMuQkxVUixcbiAgICAgICAgICAgIH0pLCBbbmFtZSwgY29udHJvbF0pLFxuICAgICAgICAgICAgcmVmOiAoZWxtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiYgZWxtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLnJlZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiAoKSA9PiBlbG0uZm9jdXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdDogKCkgPT4gZWxtLnNlbGVjdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHk6IChtZXNzYWdlKSA9PiBlbG0uc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBvcnRWYWxpZGl0eTogKCkgPT4gZWxtLnJlcG9ydFZhbGlkaXR5KCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybVN0YXRlLFxuICAgICAgICBmaWVsZFN0YXRlOiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwge1xuICAgICAgICAgICAgaW52YWxpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0RpcnR5OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNUb3VjaGVkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBnZXQoZm9ybVN0YXRlLmVycm9ycywgbmFtZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuXG4vKipcbiAqIENvbXBvbmVudCBiYXNlZCBvbiBgdXNlQ29udHJvbGxlcmAgaG9vayB0byB3b3JrIHdpdGggY29udHJvbGxlZCBjb21wb25lbnQuXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWNvbnRyb2xsZXIvY29udHJvbGxlcikg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY2LWNvbnRyb2xsZXItdHMtand5encpIOKAoiBbVmlkZW9dKGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9TjJVTmtfVUNWeUEpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdGhlIHBhdGggbmFtZSB0byB0aGUgZm9ybSBmaWVsZCB2YWx1ZSwgYW5kIHZhbGlkYXRpb24gcnVsZXMuXG4gKlxuICogQHJldHVybnMgcHJvdmlkZSBmaWVsZCBoYW5kbGVyIGZ1bmN0aW9ucywgZmllbGQgYW5kIGZvcm0gc3RhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm08Rm9ybVZhbHVlcz4oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICAgIHRlc3Q6IFwiXCJcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybT5cbiAqICAgICAgIDxDb250cm9sbGVyXG4gKiAgICAgICAgIGNvbnRyb2w9e2NvbnRyb2x9XG4gKiAgICAgICAgIG5hbWU9XCJ0ZXN0XCJcbiAqICAgICAgICAgcmVuZGVyPXsoeyBmaWVsZDogeyBvbkNoYW5nZSwgb25CbHVyLCB2YWx1ZSwgcmVmIH0sIGZvcm1TdGF0ZSwgZmllbGRTdGF0ZSB9KSA9PiAoXG4gKiAgICAgICAgICAgPD5cbiAqICAgICAgICAgICAgIDxpbnB1dFxuICogICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9IC8vIHNlbmQgdmFsdWUgdG8gaG9vayBmb3JtXG4gKiAgICAgICAgICAgICAgIG9uQmx1cj17b25CbHVyfSAvLyBub3RpZnkgd2hlbiBpbnB1dCBpcyB0b3VjaGVkXG4gKiAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX0gLy8gcmV0dXJuIHVwZGF0ZWQgdmFsdWVcbiAqICAgICAgICAgICAgICAgcmVmPXtyZWZ9IC8vIHNldCByZWYgZm9yIGZvY3VzIG1hbmFnZW1lbnRcbiAqICAgICAgICAgICAgIC8+XG4gKiAgICAgICAgICAgICA8cD57Zm9ybVN0YXRlLmlzU3VibWl0dGVkID8gXCJzdWJtaXR0ZWRcIiA6IFwiXCJ9PC9wPlxuICogICAgICAgICAgICAgPHA+e2ZpZWxkU3RhdGUuaXNUb3VjaGVkID8gXCJ0b3VjaGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICAgICAgICA8Lz5cbiAqICAgICAgICAgKX1cbiAqICAgICAgIC8+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IENvbnRyb2xsZXIgPSAocHJvcHMpID0+IHByb3BzLnJlbmRlcih1c2VDb250cm9sbGVyKHByb3BzKSk7XG5cbmNvbnN0IFBPU1RfUkVRVUVTVCA9ICdwb3N0Jztcbi8qKlxuICogRm9ybSBjb21wb25lbnQgdG8gbWFuYWdlIHN1Ym1pc3Npb24uXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdG8gc2V0dXAgc3VibWlzc2lvbiBkZXRhaWwuIHtAbGluayBGb3JtUHJvcHN9XG4gKlxuICogQHJldHVybnMgZm9ybSBjb21wb25lbnQgb3IgaGVhZGxlc3MgcmVuZGVyIHByb3AuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IGNvbnRyb2wsIGZvcm1TdGF0ZTogeyBlcnJvcnMgfSB9ID0gdXNlRm9ybSgpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Rm9ybSBhY3Rpb249XCIvYXBpXCIgY29udHJvbD17Y29udHJvbH0+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwibmFtZVwiKX0gLz5cbiAqICAgICAgIDxwPntlcnJvcnM/LnJvb3Q/LnNlcnZlciAmJiAnU2VydmVyIGVycm9yJ308L3A+XG4gKiAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxuICogICAgIDwvRm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBGb3JtKHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgb25TdWJtaXQsIGNoaWxkcmVuLCBhY3Rpb24sIG1ldGhvZCA9IFBPU1RfUkVRVUVTVCwgaGVhZGVycywgZW5jVHlwZSwgb25FcnJvciwgcmVuZGVyLCBvblN1Y2Nlc3MsIHZhbGlkYXRlU3RhdHVzLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICBjb25zdCBzdWJtaXQgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIGxldCB0eXBlID0gJyc7XG4gICAgICAgIGF3YWl0IGNvbnRyb2wuaGFuZGxlU3VibWl0KGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgbGV0IGZvcm1EYXRhSnNvbiA9ICcnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YUpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgY29udHJvbC5fbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgZ2V0KGRhdGEsIG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblN1Ym1pdCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uU3VibWl0KHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhSnNvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRTdHJpbmdpZnlTdWJtaXNzaW9uRGF0YSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgJiYgaGVhZGVyc1snQ29udGVudC1UeXBlJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNUeXBlLFxuICAgICAgICAgICAgICAgICAgICBdLnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSAmJiB2YWx1ZS5pbmNsdWRlcygnanNvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihlbmNUeXBlID8geyAnQ29udGVudC1UeXBlJzogZW5jVHlwZSB9IDoge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHNob3VsZFN0cmluZ2lmeVN1Ym1pc3Npb25EYXRhID8gZm9ybURhdGFKc29uIDogZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWxpZGF0ZVN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gIXZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLnN0YXR1cyA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPj0gMzAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvciAmJiBvbkVycm9yKHsgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gU3RyaW5nKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MgJiYgb25TdWNjZXNzKHsgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvciAmJiBvbkVycm9yKHsgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KShldmVudCk7XG4gICAgICAgIGlmIChoYXNFcnJvciAmJiBwcm9wcy5jb250cm9sKSB7XG4gICAgICAgICAgICBwcm9wcy5jb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9wcy5jb250cm9sLnNldEVycm9yKCdyb290LnNlcnZlcicsIHtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiByZW5kZXIgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcmVuZGVyKHtcbiAgICAgICAgc3VibWl0LFxuICAgIH0pKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgeyBub1ZhbGlkYXRlOiBtb3VudGVkLCBhY3Rpb246IGFjdGlvbiwgbWV0aG9kOiBtZXRob2QsIGVuY1R5cGU6IGVuY1R5cGUsIG9uU3VibWl0OiBzdWJtaXQsIC4uLnJlc3QgfSwgY2hpbGRyZW4pKTtcbn1cblxudmFyIGFwcGVuZEVycm9ycyA9IChuYW1lLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGVycm9ycywgdHlwZSwgbWVzc2FnZSkgPT4gdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhXG4gICAgPyB7XG4gICAgICAgIC4uLmVycm9yc1tuYW1lXSxcbiAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICAgIC4uLihlcnJvcnNbbmFtZV0gJiYgZXJyb3JzW25hbWVdLnR5cGVzID8gZXJyb3JzW25hbWVdLnR5cGVzIDoge30pLFxuICAgICAgICAgICAgW3R5cGVdOiBtZXNzYWdlIHx8IHRydWUsXG4gICAgICAgIH0sXG4gICAgfVxuICAgIDoge307XG5cbnZhciBnZW5lcmF0ZUlkID0gKCkgPT4ge1xuICAgIGNvbnN0IGQgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnID8gRGF0ZS5ub3coKSA6IHBlcmZvcm1hbmNlLm5vdygpICogMTAwMDtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNiArIGQpICUgMTYgfCAwO1xuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufTtcblxudmFyIGdldEZvY3VzRmllbGROYW1lID0gKG5hbWUsIGluZGV4LCBvcHRpb25zID0ge30pID0+IG9wdGlvbnMuc2hvdWxkRm9jdXMgfHwgaXNVbmRlZmluZWQob3B0aW9ucy5zaG91bGRGb2N1cylcbiAgICA/IG9wdGlvbnMuZm9jdXNOYW1lIHx8XG4gICAgICAgIGAke25hbWV9LiR7aXNVbmRlZmluZWQob3B0aW9ucy5mb2N1c0luZGV4KSA/IGluZGV4IDogb3B0aW9ucy5mb2N1c0luZGV4fS5gXG4gICAgOiAnJztcblxudmFyIGdldFZhbGlkYXRpb25Nb2RlcyA9IChtb2RlKSA9PiAoe1xuICAgIGlzT25TdWJtaXQ6ICFtb2RlIHx8IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcbiAgICBpc09uQmx1cjogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQmx1cixcbiAgICBpc09uQ2hhbmdlOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsXG4gICAgaXNPbkFsbDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbCxcbiAgICBpc09uVG91Y2g6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblRvdWNoZWQsXG59KTtcblxudmFyIGlzV2F0Y2hlZCA9IChuYW1lLCBfbmFtZXMsIGlzQmx1ckV2ZW50KSA9PiAhaXNCbHVyRXZlbnQgJiZcbiAgICAoX25hbWVzLndhdGNoQWxsIHx8XG4gICAgICAgIF9uYW1lcy53YXRjaC5oYXMobmFtZSkgfHxcbiAgICAgICAgWy4uLl9uYW1lcy53YXRjaF0uc29tZSgod2F0Y2hOYW1lKSA9PiBuYW1lLnN0YXJ0c1dpdGgod2F0Y2hOYW1lKSAmJlxuICAgICAgICAgICAgL15cXC5cXHcrLy50ZXN0KG5hbWUuc2xpY2Uod2F0Y2hOYW1lLmxlbmd0aCkpKSk7XG5cbmNvbnN0IGl0ZXJhdGVGaWVsZHNCeUFjdGlvbiA9IChmaWVsZHMsIGFjdGlvbiwgZmllbGRzTmFtZXMsIGFib3J0RWFybHkpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBmaWVsZHNOYW1lcyB8fCBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGZpZWxkcywga2V5KTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCB7IF9mLCAuLi5jdXJyZW50RmllbGQgfSA9IGZpZWxkO1xuICAgICAgICAgICAgaWYgKF9mKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9mLnJlZnMgJiYgX2YucmVmc1swXSAmJiBhY3Rpb24oX2YucmVmc1swXSwga2V5KSAmJiAhYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2YucmVmICYmIGFjdGlvbihfZi5yZWYsIF9mLm5hbWUpICYmICFhYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGN1cnJlbnRGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oY3VycmVudEZpZWxkLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IgPSAoZXJyb3JzLCBlcnJvciwgbmFtZSkgPT4ge1xuICAgIGNvbnN0IGZpZWxkQXJyYXlFcnJvcnMgPSBjb21wYWN0KGdldChlcnJvcnMsIG5hbWUpKTtcbiAgICBzZXQoZmllbGRBcnJheUVycm9ycywgJ3Jvb3QnLCBlcnJvcltuYW1lXSk7XG4gICAgc2V0KGVycm9ycywgbmFtZSwgZmllbGRBcnJheUVycm9ycyk7XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG5cbnZhciBpc0ZpbGVJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdmaWxlJztcblxudmFyIGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzSFRNTEVsZW1lbnQgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIWlzV2ViKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb3duZXIgPSB2YWx1ZSA/IHZhbHVlLm93bmVyRG9jdW1lbnQgOiAwO1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZlxuICAgICAgICAob3duZXIgJiYgb3duZXIuZGVmYXVsdFZpZXcgPyBvd25lci5kZWZhdWx0Vmlldy5IVE1MRWxlbWVudCA6IEhUTUxFbGVtZW50KSk7XG59O1xuXG52YXIgaXNNZXNzYWdlID0gKHZhbHVlKSA9PiBpc1N0cmluZyh2YWx1ZSk7XG5cbnZhciBpc1JhZGlvSW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAncmFkaW8nO1xuXG52YXIgaXNSZWdleCA9ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG5cbmNvbnN0IGRlZmF1bHRSZXN1bHQgPSB7XG4gICAgdmFsdWU6IGZhbHNlLFxuICAgIGlzVmFsaWQ6IGZhbHNlLFxufTtcbmNvbnN0IHZhbGlkUmVzdWx0ID0geyB2YWx1ZTogdHJ1ZSwgaXNWYWxpZDogdHJ1ZSB9O1xudmFyIGdldENoZWNrYm94VmFsdWUgPSAob3B0aW9ucykgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+IG9wdGlvbiAmJiBvcHRpb24uY2hlY2tlZCAmJiAhb3B0aW9uLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgIC5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZXMsIGlzVmFsaWQ6ICEhdmFsdWVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zWzBdLmNoZWNrZWQgJiYgIW9wdGlvbnNbMF0uZGlzYWJsZWRcbiAgICAgICAgICAgID8gLy8gQHRzLWV4cGVjdC1lcnJvciBleHBlY3RlZCB0byB3b3JrIGluIHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5hdHRyaWJ1dGVzICYmICFpc1VuZGVmaW5lZChvcHRpb25zWzBdLmF0dHJpYnV0ZXMudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gaXNVbmRlZmluZWQob3B0aW9uc1swXS52YWx1ZSkgfHwgb3B0aW9uc1swXS52YWx1ZSA9PT0gJydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsaWRSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyB2YWx1ZTogb3B0aW9uc1swXS52YWx1ZSwgaXNWYWxpZDogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgIDogdmFsaWRSZXN1bHRcbiAgICAgICAgICAgIDogZGVmYXVsdFJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7XG59O1xuXG5jb25zdCBkZWZhdWx0UmV0dXJuID0ge1xuICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgIHZhbHVlOiBudWxsLFxufTtcbnZhciBnZXRSYWRpb1ZhbHVlID0gKG9wdGlvbnMpID0+IEFycmF5LmlzQXJyYXkob3B0aW9ucylcbiAgICA/IG9wdGlvbnMucmVkdWNlKChwcmV2aW91cywgb3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLFxuICAgICAgICB9XG4gICAgICAgIDogcHJldmlvdXMsIGRlZmF1bHRSZXR1cm4pXG4gICAgOiBkZWZhdWx0UmV0dXJuO1xuXG5mdW5jdGlvbiBnZXRWYWxpZGF0ZUVycm9yKHJlc3VsdCwgcmVmLCB0eXBlID0gJ3ZhbGlkYXRlJykge1xuICAgIGlmIChpc01lc3NhZ2UocmVzdWx0KSB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5ldmVyeShpc01lc3NhZ2UpKSB8fFxuICAgICAgICAoaXNCb29sZWFuKHJlc3VsdCkgJiYgIXJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBpc01lc3NhZ2UocmVzdWx0KSA/IHJlc3VsdCA6ICcnLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxudmFyIGdldFZhbHVlQW5kTWVzc2FnZSA9ICh2YWxpZGF0aW9uRGF0YSkgPT4gaXNPYmplY3QodmFsaWRhdGlvbkRhdGEpICYmICFpc1JlZ2V4KHZhbGlkYXRpb25EYXRhKVxuICAgID8gdmFsaWRhdGlvbkRhdGFcbiAgICA6IHtcbiAgICAgICAgdmFsdWU6IHZhbGlkYXRpb25EYXRhLFxuICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICB9O1xuXG52YXIgdmFsaWRhdGVGaWVsZCA9IGFzeW5jIChmaWVsZCwgZm9ybVZhbHVlcywgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uLCBpc0ZpZWxkQXJyYXkpID0+IHtcbiAgICBjb25zdCB7IHJlZiwgcmVmcywgcmVxdWlyZWQsIG1heExlbmd0aCwgbWluTGVuZ3RoLCBtaW4sIG1heCwgcGF0dGVybiwgdmFsaWRhdGUsIG5hbWUsIHZhbHVlQXNOdW1iZXIsIG1vdW50LCBkaXNhYmxlZCwgfSA9IGZpZWxkLl9mO1xuICAgIGNvbnN0IGlucHV0VmFsdWUgPSBnZXQoZm9ybVZhbHVlcywgbmFtZSk7XG4gICAgaWYgKCFtb3VudCB8fCBkaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGlucHV0UmVmID0gcmVmcyA/IHJlZnNbMF0gOiByZWY7XG4gICAgY29uc3Qgc2V0Q3VzdG9tVmFsaWRpdHkgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiAmJiBpbnB1dFJlZi5yZXBvcnRWYWxpZGl0eSkge1xuICAgICAgICAgICAgaW5wdXRSZWYuc2V0Q3VzdG9tVmFsaWRpdHkoaXNCb29sZWFuKG1lc3NhZ2UpID8gJycgOiBtZXNzYWdlIHx8ICcnKTtcbiAgICAgICAgICAgIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVycm9yID0ge307XG4gICAgY29uc3QgaXNSYWRpbyA9IGlzUmFkaW9JbnB1dChyZWYpO1xuICAgIGNvbnN0IGlzQ2hlY2tCb3ggPSBpc0NoZWNrQm94SW5wdXQocmVmKTtcbiAgICBjb25zdCBpc1JhZGlvT3JDaGVja2JveCA9IGlzUmFkaW8gfHwgaXNDaGVja0JveDtcbiAgICBjb25zdCBpc0VtcHR5ID0gKCh2YWx1ZUFzTnVtYmVyIHx8IGlzRmlsZUlucHV0KHJlZikpICYmXG4gICAgICAgIGlzVW5kZWZpbmVkKHJlZi52YWx1ZSkgJiZcbiAgICAgICAgaXNVbmRlZmluZWQoaW5wdXRWYWx1ZSkpIHx8XG4gICAgICAgIChpc0hUTUxFbGVtZW50KHJlZikgJiYgcmVmLnZhbHVlID09PSAnJykgfHxcbiAgICAgICAgaW5wdXRWYWx1ZSA9PT0gJycgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkgJiYgIWlucHV0VmFsdWUubGVuZ3RoKTtcbiAgICBjb25zdCBhcHBlbmRFcnJvcnNDdXJyeSA9IGFwcGVuZEVycm9ycy5iaW5kKG51bGwsIG5hbWUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZXJyb3IpO1xuICAgIGNvbnN0IGdldE1pbk1heE1lc3NhZ2UgPSAoZXhjZWVkTWF4LCBtYXhMZW5ndGhNZXNzYWdlLCBtaW5MZW5ndGhNZXNzYWdlLCBtYXhUeXBlID0gSU5QVVRfVkFMSURBVElPTl9SVUxFUy5tYXhMZW5ndGgsIG1pblR5cGUgPSBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1pbkxlbmd0aCkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXhjZWVkTWF4ID8gbWF4TGVuZ3RoTWVzc2FnZSA6IG1pbkxlbmd0aE1lc3NhZ2U7XG4gICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgdHlwZTogZXhjZWVkTWF4ID8gbWF4VHlwZSA6IG1pblR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoZXhjZWVkTWF4ID8gbWF4VHlwZSA6IG1pblR5cGUsIG1lc3NhZ2UpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgaWYgKGlzRmllbGRBcnJheVxuICAgICAgICA/ICFBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpIHx8ICFpbnB1dFZhbHVlLmxlbmd0aFxuICAgICAgICA6IHJlcXVpcmVkICYmXG4gICAgICAgICAgICAoKCFpc1JhZGlvT3JDaGVja2JveCAmJiAoaXNFbXB0eSB8fCBpc051bGxPclVuZGVmaW5lZChpbnB1dFZhbHVlKSkpIHx8XG4gICAgICAgICAgICAgICAgKGlzQm9vbGVhbihpbnB1dFZhbHVlKSAmJiAhaW5wdXRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAoaXNDaGVja0JveCAmJiAhZ2V0Q2hlY2tib3hWYWx1ZShyZWZzKS5pc1ZhbGlkKSB8fFxuICAgICAgICAgICAgICAgIChpc1JhZGlvICYmICFnZXRSYWRpb1ZhbHVlKHJlZnMpLmlzVmFsaWQpKSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBtZXNzYWdlIH0gPSBpc01lc3NhZ2UocmVxdWlyZWQpXG4gICAgICAgICAgICA/IHsgdmFsdWU6ICEhcmVxdWlyZWQsIG1lc3NhZ2U6IHJlcXVpcmVkIH1cbiAgICAgICAgICAgIDogZ2V0VmFsdWVBbmRNZXNzYWdlKHJlcXVpcmVkKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnJlcXVpcmVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgcmVmOiBpbnB1dFJlZixcbiAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnJlcXVpcmVkLCBtZXNzYWdlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzRW1wdHkgJiYgKCFpc051bGxPclVuZGVmaW5lZChtaW4pIHx8ICFpc051bGxPclVuZGVmaW5lZChtYXgpKSkge1xuICAgICAgICBsZXQgZXhjZWVkTWF4O1xuICAgICAgICBsZXQgZXhjZWVkTWluO1xuICAgICAgICBjb25zdCBtYXhPdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWF4KTtcbiAgICAgICAgY29uc3QgbWluT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbik7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoaW5wdXRWYWx1ZSkgJiYgIWlzTmFOKGlucHV0VmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU51bWJlciA9IHJlZi52YWx1ZUFzTnVtYmVyIHx8XG4gICAgICAgICAgICAgICAgKGlucHV0VmFsdWUgPyAraW5wdXRWYWx1ZSA6IGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtYXhPdXRwdXQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWF4ID0gdmFsdWVOdW1iZXIgPiBtYXhPdXRwdXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1pbk91dHB1dC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNaW4gPSB2YWx1ZU51bWJlciA8IG1pbk91dHB1dC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0ZSA9IHJlZi52YWx1ZUFzRGF0ZSB8fCBuZXcgRGF0ZShpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRUaW1lVG9EYXRlID0gKHRpbWUpID0+IG5ldyBEYXRlKG5ldyBEYXRlKCkudG9EYXRlU3RyaW5nKCkgKyAnICcgKyB0aW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVGltZSA9IHJlZi50eXBlID09ICd0aW1lJztcbiAgICAgICAgICAgIGNvbnN0IGlzV2VlayA9IHJlZi50eXBlID09ICd3ZWVrJztcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhtYXhPdXRwdXQudmFsdWUpICYmIGlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNYXggPSBpc1RpbWVcbiAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0VGltZVRvRGF0ZShpbnB1dFZhbHVlKSA+IGNvbnZlcnRUaW1lVG9EYXRlKG1heE91dHB1dC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBpc1dlZWtcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5wdXRWYWx1ZSA+IG1heE91dHB1dC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZURhdGUgPiBuZXcgRGF0ZShtYXhPdXRwdXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1pbk91dHB1dC52YWx1ZSkgJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1pbiA9IGlzVGltZVxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRUaW1lVG9EYXRlKGlucHV0VmFsdWUpIDwgY29udmVydFRpbWVUb0RhdGUobWluT3V0cHV0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IGlzV2Vla1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnB1dFZhbHVlIDwgbWluT3V0cHV0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlRGF0ZSA8IG5ldyBEYXRlKG1pbk91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4Y2VlZE1heCB8fCBleGNlZWRNaW4pIHtcbiAgICAgICAgICAgIGdldE1pbk1heE1lc3NhZ2UoISFleGNlZWRNYXgsIG1heE91dHB1dC5tZXNzYWdlLCBtaW5PdXRwdXQubWVzc2FnZSwgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5tYXgsIElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWluKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3JbbmFtZV0ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgobWF4TGVuZ3RoIHx8IG1pbkxlbmd0aCkgJiZcbiAgICAgICAgIWlzRW1wdHkgJiZcbiAgICAgICAgKGlzU3RyaW5nKGlucHV0VmFsdWUpIHx8IChpc0ZpZWxkQXJyYXkgJiYgQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSkpKSB7XG4gICAgICAgIGNvbnN0IG1heExlbmd0aE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXhMZW5ndGgpO1xuICAgICAgICBjb25zdCBtaW5MZW5ndGhPdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWluTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZXhjZWVkTWF4ID0gIWlzTnVsbE9yVW5kZWZpbmVkKG1heExlbmd0aE91dHB1dC52YWx1ZSkgJiZcbiAgICAgICAgICAgIGlucHV0VmFsdWUubGVuZ3RoID4gK21heExlbmd0aE91dHB1dC52YWx1ZTtcbiAgICAgICAgY29uc3QgZXhjZWVkTWluID0gIWlzTnVsbE9yVW5kZWZpbmVkKG1pbkxlbmd0aE91dHB1dC52YWx1ZSkgJiZcbiAgICAgICAgICAgIGlucHV0VmFsdWUubGVuZ3RoIDwgK21pbkxlbmd0aE91dHB1dC52YWx1ZTtcbiAgICAgICAgaWYgKGV4Y2VlZE1heCB8fCBleGNlZWRNaW4pIHtcbiAgICAgICAgICAgIGdldE1pbk1heE1lc3NhZ2UoZXhjZWVkTWF4LCBtYXhMZW5ndGhPdXRwdXQubWVzc2FnZSwgbWluTGVuZ3RoT3V0cHV0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShlcnJvcltuYW1lXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdHRlcm4gJiYgIWlzRW1wdHkgJiYgaXNTdHJpbmcoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogcGF0dGVyblZhbHVlLCBtZXNzYWdlIH0gPSBnZXRWYWx1ZUFuZE1lc3NhZ2UocGF0dGVybik7XG4gICAgICAgIGlmIChpc1JlZ2V4KHBhdHRlcm5WYWx1ZSkgJiYgIWlucHV0VmFsdWUubWF0Y2gocGF0dGVyblZhbHVlKSkge1xuICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogSU5QVVRfVkFMSURBVElPTl9SVUxFUy5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KElOUFVUX1ZBTElEQVRJT05fUlVMRVMucGF0dGVybiwgbWVzc2FnZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbGlkYXRlKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRlKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGUoaW5wdXRWYWx1ZSwgZm9ybVZhbHVlcyk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihyZXN1bHQsIGlucHV0UmVmKTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkYXRlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KElOUFVUX1ZBTElEQVRJT05fUlVMRVMudmFsaWRhdGUsIHZhbGlkYXRlRXJyb3IubWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eSh2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbGlkYXRlKSkge1xuICAgICAgICAgICAgbGV0IHZhbGlkYXRpb25SZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHZhbGlkYXRpb25SZXN1bHQpICYmICF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSBnZXRWYWxpZGF0ZUVycm9yKGF3YWl0IHZhbGlkYXRlW2tleV0oaW5wdXRWYWx1ZSwgZm9ybVZhbHVlcyksIGlucHV0UmVmLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi52YWxpZGF0ZUVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3Vycnkoa2V5LCB2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eSh2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IHZhbGlkYXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBpbnB1dFJlZixcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRhdGlvblJlc3VsdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3VzdG9tVmFsaWRpdHkodHJ1ZSk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcblxuZnVuY3Rpb24gYXBwZW5kKGRhdGEsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFsuLi5kYXRhLCAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpXTtcbn1cblxudmFyIGZpbGxFbXB0eUFycmF5ID0gKHZhbHVlKSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgoKSA9PiB1bmRlZmluZWQpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpbnNlcnQoZGF0YSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLi4uZGF0YS5zbGljZSgwLCBpbmRleCksXG4gICAgICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZCh2YWx1ZSksXG4gICAgICAgIC4uLmRhdGEuc2xpY2UoaW5kZXgpLFxuICAgIF07XG59XG5cbnZhciBtb3ZlQXJyYXlBdCA9IChkYXRhLCBmcm9tLCB0bykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpc1VuZGVmaW5lZChkYXRhW3RvXSkpIHtcbiAgICAgICAgZGF0YVt0b10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRhdGEuc3BsaWNlKHRvLCAwLCBkYXRhLnNwbGljZShmcm9tLCAxKVswXSk7XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG5mdW5jdGlvbiBwcmVwZW5kKGRhdGEsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFsuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpLCAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQoZGF0YSldO1xufVxuXG5mdW5jdGlvbiByZW1vdmVBdEluZGV4ZXMoZGF0YSwgaW5kZXhlcykge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCB0ZW1wID0gWy4uLmRhdGFdO1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcykge1xuICAgICAgICB0ZW1wLnNwbGljZShpbmRleCAtIGksIDEpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBjb21wYWN0KHRlbXApLmxlbmd0aCA/IHRlbXAgOiBbXTtcbn1cbnZhciByZW1vdmVBcnJheUF0ID0gKGRhdGEsIGluZGV4KSA9PiBpc1VuZGVmaW5lZChpbmRleClcbiAgICA/IFtdXG4gICAgOiByZW1vdmVBdEluZGV4ZXMoZGF0YSwgY29udmVydFRvQXJyYXlQYXlsb2FkKGluZGV4KS5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuXG52YXIgc3dhcEFycmF5QXQgPSAoZGF0YSwgaW5kZXhBLCBpbmRleEIpID0+IHtcbiAgICBkYXRhW2luZGV4QV0gPSBbZGF0YVtpbmRleEJdLCAoZGF0YVtpbmRleEJdID0gZGF0YVtpbmRleEFdKV1bMF07XG59O1xuXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgdXBkYXRlUGF0aCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHVwZGF0ZVBhdGguc2xpY2UoMCwgLTEpLmxlbmd0aDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBpc1VuZGVmaW5lZChvYmplY3QpID8gaW5kZXgrKyA6IG9iamVjdFt1cGRhdGVQYXRoW2luZGV4KytdXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlBcnJheShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShwYXRoKVxuICAgICAgICA/IHBhdGhcbiAgICAgICAgOiBpc0tleShwYXRoKVxuICAgICAgICAgICAgPyBbcGF0aF1cbiAgICAgICAgICAgIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xuICAgIGNvbnN0IGNoaWxkT2JqZWN0ID0gcGF0aHMubGVuZ3RoID09PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIHBhdGhzKTtcbiAgICBjb25zdCBpbmRleCA9IHBhdGhzLmxlbmd0aCAtIDE7XG4gICAgY29uc3Qga2V5ID0gcGF0aHNbaW5kZXhdO1xuICAgIGlmIChjaGlsZE9iamVjdCkge1xuICAgICAgICBkZWxldGUgY2hpbGRPYmplY3Rba2V5XTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSAwICYmXG4gICAgICAgICgoaXNPYmplY3QoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlPYmplY3QoY2hpbGRPYmplY3QpKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlBcnJheShjaGlsZE9iamVjdCkpKSkge1xuICAgICAgICB1bnNldChvYmplY3QsIHBhdGhzLnNsaWNlKDAsIC0xKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciB1cGRhdGVBdCA9IChmaWVsZFZhbHVlcywgaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgZmllbGRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgcmV0dXJuIGZpZWxkVmFsdWVzO1xufTtcblxuLyoqXG4gKiBBIGN1c3RvbSBob29rIHRoYXQgZXhwb3NlcyBjb252ZW5pZW50IG1ldGhvZHMgdG8gcGVyZm9ybSBvcGVyYXRpb25zIHdpdGggYSBsaXN0IG9mIGR5bmFtaWMgaW5wdXRzIHRoYXQgbmVlZCB0byBiZSBhcHBlbmRlZCwgdXBkYXRlZCwgcmVtb3ZlZCBldGMuIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS11c2VmaWVsZGFycmF5LXNzdWduKSDigKIgW1ZpZGVvXShodHRwczovL3lvdXR1LmJlLzRNcmJmR1NGWTJBKVxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2VmaWVsZGFycmF5KSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdXNlZmllbGRhcnJheS1zc3VnbilcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB1c2VGaWVsZEFycmF5IHByb3BzXG4gKlxuICogQHJldHVybnMgbWV0aG9kcyAtIGZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIHdpdGggdGhlIEZpZWxkIEFycmF5cyAoZHluYW1pYyBpbnB1dHMpIHtAbGluayBVc2VGaWVsZEFycmF5UmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciwgY29udHJvbCwgaGFuZGxlU3VibWl0LCByZXNldCwgdHJpZ2dlciwgc2V0RXJyb3IgfSA9IHVzZUZvcm0oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICAgIHRlc3Q6IFtdXG4gKiAgICAgfVxuICogICB9KTtcbiAqICAgY29uc3QgeyBmaWVsZHMsIGFwcGVuZCB9ID0gdXNlRmllbGRBcnJheSh7XG4gKiAgICAgY29udHJvbCxcbiAqICAgICBuYW1lOiBcInRlc3RcIlxuICogICB9KTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpKX0+XG4gKiAgICAgICB7ZmllbGRzLm1hcCgoaXRlbSwgaW5kZXgpID0+IChcbiAqICAgICAgICAgIDxpbnB1dCBrZXk9e2l0ZW0uaWR9IHsuLi5yZWdpc3RlcihgdGVzdC4ke2luZGV4fS5maXJzdE5hbWVgKX0gIC8+XG4gKiAgICAgICApKX1cbiAqICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IGFwcGVuZCh7IGZpcnN0TmFtZTogXCJiaWxsXCIgfSl9PlxuICogICAgICAgICBhcHBlbmRcbiAqICAgICAgIDwvYnV0dG9uPlxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGaWVsZEFycmF5KHByb3BzKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBuYW1lLCBrZXlOYW1lID0gJ2lkJywgc2hvdWxkVW5yZWdpc3RlciwgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtmaWVsZHMsIHNldEZpZWxkc10gPSBSZWFjdC51c2VTdGF0ZShjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpKTtcbiAgICBjb25zdCBpZHMgPSBSZWFjdC51c2VSZWYoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgIGNvbnN0IF9maWVsZElkcyA9IFJlYWN0LnVzZVJlZihmaWVsZHMpO1xuICAgIGNvbnN0IF9uYW1lID0gUmVhY3QudXNlUmVmKG5hbWUpO1xuICAgIGNvbnN0IF9hY3Rpb25lZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgX25hbWUuY3VycmVudCA9IG5hbWU7XG4gICAgX2ZpZWxkSWRzLmN1cnJlbnQgPSBmaWVsZHM7XG4gICAgY29udHJvbC5fbmFtZXMuYXJyYXkuYWRkKG5hbWUpO1xuICAgIHByb3BzLnJ1bGVzICYmXG4gICAgICAgIGNvbnRyb2wucmVnaXN0ZXIobmFtZSwgcHJvcHMucnVsZXMpO1xuICAgIHVzZVN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICh7IHZhbHVlcywgbmFtZTogZmllbGRBcnJheU5hbWUsIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZEFycmF5TmFtZSA9PT0gX25hbWUuY3VycmVudCB8fCAhZmllbGRBcnJheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldCh2YWx1ZXMsIF9uYW1lLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkVmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRGaWVsZHMoZmllbGRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZHMuY3VycmVudCA9IGZpZWxkVmFsdWVzLm1hcChnZW5lcmF0ZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN1YmplY3Q6IGNvbnRyb2wuX3N1YmplY3RzLmFycmF5LFxuICAgIH0pO1xuICAgIGNvbnN0IHVwZGF0ZVZhbHVlcyA9IFJlYWN0LnVzZUNhbGxiYWNrKCh1cGRhdGVkRmllbGRBcnJheVZhbHVlcykgPT4ge1xuICAgICAgICBfYWN0aW9uZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgIH0sIFtjb250cm9sLCBuYW1lXSk7XG4gICAgY29uc3QgYXBwZW5kJDEgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgYXBwZW5kVmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBhcHBlbmQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgYXBwZW5kVmFsdWUpO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9IGdldEZvY3VzRmllbGROYW1lKG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLmxlbmd0aCAtIDEsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IGFwcGVuZChpZHMuY3VycmVudCwgYXBwZW5kVmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgYXBwZW5kLCB7XG4gICAgICAgICAgICBhcmdBOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcHJlcGVuZCQxID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXBlbmRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHByZXBlbmQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgcHJlcGVuZFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCAwLCBvcHRpb25zKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBwcmVwZW5kKGlkcy5jdXJyZW50LCBwcmVwZW5kVmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgcHJlcGVuZCwge1xuICAgICAgICAgICAgYXJnQTogZmlsbEVtcHR5QXJyYXkodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSA9IChpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHJlbW92ZUFycmF5QXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgpO1xuICAgICAgICBpZHMuY3VycmVudCA9IHJlbW92ZUFycmF5QXQoaWRzLmN1cnJlbnQsIGluZGV4KTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgcmVtb3ZlQXJyYXlBdCwge1xuICAgICAgICAgICAgYXJnQTogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0JDEgPSAoaW5kZXgsIHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGluc2VydFZhbHVlID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gaW5zZXJ0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGluZGV4LCBpbnNlcnRWYWx1ZSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzID0gZ2V0Rm9jdXNGaWVsZE5hbWUobmFtZSwgaW5kZXgsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IGluc2VydChpZHMuY3VycmVudCwgaW5kZXgsIGluc2VydFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGluc2VydCwge1xuICAgICAgICAgICAgYXJnQTogaW5kZXgsXG4gICAgICAgICAgICBhcmdCOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc3dhcCA9IChpbmRleEEsIGluZGV4QikgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIHN3YXBBcnJheUF0KHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBpbmRleEEsIGluZGV4Qik7XG4gICAgICAgIHN3YXBBcnJheUF0KGlkcy5jdXJyZW50LCBpbmRleEEsIGluZGV4Qik7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHN3YXBBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleEEsXG4gICAgICAgICAgICBhcmdCOiBpbmRleEIsXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmUgPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpO1xuICAgICAgICBtb3ZlQXJyYXlBdCh1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgZnJvbSwgdG8pO1xuICAgICAgICBtb3ZlQXJyYXlBdChpZHMuY3VycmVudCwgZnJvbSwgdG8pO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBtb3ZlQXJyYXlBdCwge1xuICAgICAgICAgICAgYXJnQTogZnJvbSxcbiAgICAgICAgICAgIGFyZ0I6IHRvLFxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGUgPSAoaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gY2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHVwZGF0ZUF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGluZGV4LCB1cGRhdGVWYWx1ZSk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXS5tYXAoKGl0ZW0sIGkpID0+ICFpdGVtIHx8IGkgPT09IGluZGV4ID8gZ2VuZXJhdGVJZCgpIDogaWRzLmN1cnJlbnRbaV0pO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHMoWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXSk7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHVwZGF0ZUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgICAgIGFyZ0I6IHVwZGF0ZVZhbHVlLFxuICAgICAgICB9LCB0cnVlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCByZXBsYWNlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMubWFwKGdlbmVyYXRlSWQpO1xuICAgICAgICB1cGRhdGVWYWx1ZXMoWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXSk7XG4gICAgICAgIHNldEZpZWxkcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCBbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdLCAoZGF0YSkgPT4gZGF0YSwge30sIHRydWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuX3N0YXRlLmFjdGlvbiA9IGZhbHNlO1xuICAgICAgICBpc1dhdGNoZWQobmFtZSwgY29udHJvbC5fbmFtZXMpICYmXG4gICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAuLi5jb250cm9sLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKF9hY3Rpb25lZC5jdXJyZW50ICYmXG4gICAgICAgICAgICAoIWdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLm1vZGUpLmlzT25TdWJtaXQgfHxcbiAgICAgICAgICAgICAgICBjb250cm9sLl9mb3JtU3RhdGUuaXNTdWJtaXR0ZWQpKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbC5fb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX2V4ZWN1dGVTY2hlbWEoW25hbWVdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXQocmVzdWx0LmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXJyb3IgPSBnZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICghZXJyb3IgJiYgZXhpc3RpbmdFcnJvci50eXBlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXhpc3RpbmdFcnJvci50eXBlICE9PSBlcnJvci50eXBlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0Vycm9yLm1lc3NhZ2UgIT09IGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBlcnJvciAmJiBlcnJvci50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGaWVsZChmaWVsZCwgY29udHJvbC5fZm9ybVZhbHVlcywgY29udHJvbC5fb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGwsIGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgdHJ1ZSkudGhlbigoZXJyb3IpID0+ICFpc0VtcHR5T2JqZWN0KGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiB1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yKGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIGVycm9yLCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5fc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlczogeyAuLi5jb250cm9sLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyAmJlxuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGNvbnRyb2wuX2ZpZWxkcywgKHJlZiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuX25hbWVzLmZvY3VzICYmXG4gICAgICAgICAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKGNvbnRyb2wuX25hbWVzLmZvY3VzKSAmJlxuICAgICAgICAgICAgICAgICAgICByZWYuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSAnJztcbiAgICAgICAgY29udHJvbC5fdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgX2FjdGlvbmVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LCBbZmllbGRzLCBuYW1lLCBjb250cm9sXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgIWdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSAmJiBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgKGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBzaG91bGRVbnJlZ2lzdGVyKSAmJlxuICAgICAgICAgICAgICAgIGNvbnRyb2wudW5yZWdpc3RlcihuYW1lKTtcbiAgICAgICAgfTtcbiAgICB9LCBbbmFtZSwgY29udHJvbCwga2V5TmFtZSwgc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN3YXA6IFJlYWN0LnVzZUNhbGxiYWNrKHN3YXAsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgbW92ZTogUmVhY3QudXNlQ2FsbGJhY2sobW92ZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBwcmVwZW5kOiBSZWFjdC51c2VDYWxsYmFjayhwcmVwZW5kJDEsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgYXBwZW5kOiBSZWFjdC51c2VDYWxsYmFjayhhcHBlbmQkMSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICByZW1vdmU6IFJlYWN0LnVzZUNhbGxiYWNrKHJlbW92ZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBpbnNlcnQ6IFJlYWN0LnVzZUNhbGxiYWNrKGluc2VydCQxLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHVwZGF0ZTogUmVhY3QudXNlQ2FsbGJhY2sodXBkYXRlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHJlcGxhY2U6IFJlYWN0LnVzZUNhbGxiYWNrKHJlcGxhY2UsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgZmllbGRzOiBSZWFjdC51c2VNZW1vKCgpID0+IGZpZWxkcy5tYXAoKGZpZWxkLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgIC4uLmZpZWxkLFxuICAgICAgICAgICAgW2tleU5hbWVdOiBpZHMuY3VycmVudFtpbmRleF0gfHwgZ2VuZXJhdGVJZCgpLFxuICAgICAgICB9KSksIFtmaWVsZHMsIGtleU5hbWVdKSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdWJqZWN0KCkge1xuICAgIGxldCBfb2JzZXJ2ZXJzID0gW107XG4gICAgY29uc3QgbmV4dCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIF9vYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IChvYnNlcnZlcikgPT4ge1xuICAgICAgICBfb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBfb2JzZXJ2ZXJzID0gX29ic2VydmVycy5maWx0ZXIoKG8pID0+IG8gIT09IG9ic2VydmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgICAgX29ic2VydmVycyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JzZXJ2ZXJzO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0LFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIHVuc3Vic2NyaWJlLFxuICAgIH07XG59XG5cbnZhciBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8ICFpc09iamVjdFR5cGUodmFsdWUpO1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwob2JqZWN0MSwgb2JqZWN0Mikge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmplY3QxKSB8fCBpc1ByaW1pdGl2ZShvYmplY3QyKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0MSA9PT0gb2JqZWN0MjtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZU9iamVjdChvYmplY3QxKSAmJiBpc0RhdGVPYmplY3Qob2JqZWN0MikpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDEuZ2V0VGltZSgpID09PSBvYmplY3QyLmdldFRpbWUoKTtcbiAgICB9XG4gICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmplY3QxKTtcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG4gICAgICAgIGNvbnN0IHZhbDEgPSBvYmplY3QxW2tleV07XG4gICAgICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgIT09ICdyZWYnKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gb2JqZWN0MltrZXldO1xuICAgICAgICAgICAgaWYgKChpc0RhdGVPYmplY3QodmFsMSkgJiYgaXNEYXRlT2JqZWN0KHZhbDIpKSB8fFxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwxKSAmJiBpc09iamVjdCh2YWwyKSkgfHxcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh2YWwxKSAmJiBBcnJheS5pc0FycmF5KHZhbDIpKVxuICAgICAgICAgICAgICAgID8gIWRlZXBFcXVhbCh2YWwxLCB2YWwyKVxuICAgICAgICAgICAgICAgIDogdmFsMSAhPT0gdmFsMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGlzTXVsdGlwbGVTZWxlY3QgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSBgc2VsZWN0LW11bHRpcGxlYDtcblxudmFyIGlzUmFkaW9PckNoZWNrYm94ID0gKHJlZikgPT4gaXNSYWRpb0lucHV0KHJlZikgfHwgaXNDaGVja0JveElucHV0KHJlZik7XG5cbnZhciBsaXZlID0gKHJlZikgPT4gaXNIVE1MRWxlbWVudChyZWYpICYmIHJlZi5pc0Nvbm5lY3RlZDtcblxudmFyIG9iamVjdEhhc0Z1bmN0aW9uID0gKGRhdGEpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIG1hcmtGaWVsZHNEaXJ0eShkYXRhLCBmaWVsZHMgPSB7fSkge1xuICAgIGNvbnN0IGlzUGFyZW50Tm9kZUFycmF5ID0gQXJyYXkuaXNBcnJheShkYXRhKTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkgfHwgaXNQYXJlbnROb2RlQXJyYXkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSB8fFxuICAgICAgICAgICAgICAgIChpc09iamVjdChkYXRhW2tleV0pICYmICFvYmplY3RIYXNGdW5jdGlvbihkYXRhW2tleV0pKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gQXJyYXkuaXNBcnJheShkYXRhW2tleV0pID8gW10gOiB7fTtcbiAgICAgICAgICAgICAgICBtYXJrRmllbGRzRGlydHkoZGF0YVtrZXldLCBmaWVsZHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQoZGF0YVtrZXldKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuZnVuY3Rpb24gZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyhkYXRhLCBmb3JtVmFsdWVzLCBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXMpIHtcbiAgICBjb25zdCBpc1BhcmVudE5vZGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpIHx8IGlzUGFyZW50Tm9kZUFycmF5KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QoZGF0YVtrZXldKSAmJiAhb2JqZWN0SGFzRnVuY3Rpb24oZGF0YVtrZXldKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZm9ybVZhbHVlcykgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmltaXRpdmUoZGlydHlGaWVsZHNGcm9tVmFsdWVzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldID0gQXJyYXkuaXNBcnJheShkYXRhW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1hcmtGaWVsZHNEaXJ0eShkYXRhW2tleV0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IC4uLm1hcmtGaWVsZHNEaXJ0eShkYXRhW2tleV0pIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXREaXJ0eUZpZWxkc0Zyb21EZWZhdWx0VmFsdWVzKGRhdGFba2V5XSwgaXNOdWxsT3JVbmRlZmluZWQoZm9ybVZhbHVlcykgPyB7fSA6IGZvcm1WYWx1ZXNba2V5XSwgZGlydHlGaWVsZHNGcm9tVmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldID0gIWRlZXBFcXVhbChkYXRhW2tleV0sIGZvcm1WYWx1ZXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpcnR5RmllbGRzRnJvbVZhbHVlcztcbn1cbnZhciBnZXREaXJ0eUZpZWxkcyA9IChkZWZhdWx0VmFsdWVzLCBmb3JtVmFsdWVzKSA9PiBnZXREaXJ0eUZpZWxkc0Zyb21EZWZhdWx0VmFsdWVzKGRlZmF1bHRWYWx1ZXMsIGZvcm1WYWx1ZXMsIG1hcmtGaWVsZHNEaXJ0eShmb3JtVmFsdWVzKSk7XG5cbnZhciBnZXRGaWVsZFZhbHVlQXMgPSAodmFsdWUsIHsgdmFsdWVBc051bWJlciwgdmFsdWVBc0RhdGUsIHNldFZhbHVlQXMgfSkgPT4gaXNVbmRlZmluZWQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogdmFsdWVBc051bWJlclxuICAgICAgICA/IHZhbHVlID09PSAnJ1xuICAgICAgICAgICAgPyBOYU5cbiAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgICAgICAgICA/ICt2YWx1ZVxuICAgICAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgOiB2YWx1ZUFzRGF0ZSAmJiBpc1N0cmluZyh2YWx1ZSlcbiAgICAgICAgICAgID8gbmV3IERhdGUodmFsdWUpXG4gICAgICAgICAgICA6IHNldFZhbHVlQXNcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlQXModmFsdWUpXG4gICAgICAgICAgICAgICAgOiB2YWx1ZTtcblxuZnVuY3Rpb24gZ2V0RmllbGRWYWx1ZShfZikge1xuICAgIGNvbnN0IHJlZiA9IF9mLnJlZjtcbiAgICBpZiAoX2YucmVmcyA/IF9mLnJlZnMuZXZlcnkoKHJlZikgPT4gcmVmLmRpc2FibGVkKSA6IHJlZi5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0ZpbGVJbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiByZWYuZmlsZXM7XG4gICAgfVxuICAgIGlmIChpc1JhZGlvSW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gZ2V0UmFkaW9WYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QocmVmKSkge1xuICAgICAgICByZXR1cm4gWy4uLnJlZi5zZWxlY3RlZE9wdGlvbnNdLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0NoZWNrQm94SW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEZpZWxkVmFsdWVBcyhpc1VuZGVmaW5lZChyZWYudmFsdWUpID8gX2YucmVmLnZhbHVlIDogcmVmLnZhbHVlLCBfZik7XG59XG5cbnZhciBnZXRSZXNvbHZlck9wdGlvbnMgPSAoZmllbGRzTmFtZXMsIF9maWVsZHMsIGNyaXRlcmlhTW9kZSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikgPT4ge1xuICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBmaWVsZHNOYW1lcykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgZmllbGQgJiYgc2V0KGZpZWxkcywgbmFtZSwgZmllbGQuX2YpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcml0ZXJpYU1vZGUsXG4gICAgICAgIG5hbWVzOiBbLi4uZmllbGRzTmFtZXNdLFxuICAgICAgICBmaWVsZHMsXG4gICAgICAgIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sXG4gICAgfTtcbn07XG5cbnZhciBnZXRSdWxlVmFsdWUgPSAocnVsZSkgPT4gaXNVbmRlZmluZWQocnVsZSlcbiAgICA/IHJ1bGVcbiAgICA6IGlzUmVnZXgocnVsZSlcbiAgICAgICAgPyBydWxlLnNvdXJjZVxuICAgICAgICA6IGlzT2JqZWN0KHJ1bGUpXG4gICAgICAgICAgICA/IGlzUmVnZXgocnVsZS52YWx1ZSlcbiAgICAgICAgICAgICAgICA/IHJ1bGUudmFsdWUuc291cmNlXG4gICAgICAgICAgICAgICAgOiBydWxlLnZhbHVlXG4gICAgICAgICAgICA6IHJ1bGU7XG5cbnZhciBoYXNWYWxpZGF0aW9uID0gKG9wdGlvbnMpID0+IG9wdGlvbnMubW91bnQgJiZcbiAgICAob3B0aW9ucy5yZXF1aXJlZCB8fFxuICAgICAgICBvcHRpb25zLm1pbiB8fFxuICAgICAgICBvcHRpb25zLm1heCB8fFxuICAgICAgICBvcHRpb25zLm1heExlbmd0aCB8fFxuICAgICAgICBvcHRpb25zLm1pbkxlbmd0aCB8fFxuICAgICAgICBvcHRpb25zLnBhdHRlcm4gfHxcbiAgICAgICAgb3B0aW9ucy52YWxpZGF0ZSk7XG5cbmZ1bmN0aW9uIHNjaGVtYUVycm9yTG9va3VwKGVycm9ycywgX2ZpZWxkcywgbmFtZSkge1xuICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgaWYgKGVycm9yIHx8IGlzS2V5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIHdoaWxlIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZmllbGROYW1lID0gbmFtZXMuam9pbignLicpO1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICBjb25zdCBmb3VuZEVycm9yID0gZ2V0KGVycm9ycywgZmllbGROYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkICYmICFBcnJheS5pc0FycmF5KGZpZWxkKSAmJiBuYW1lICE9PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRFcnJvciAmJiBmb3VuZEVycm9yLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmb3VuZEVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICB9O1xufVxuXG52YXIgc2tpcFZhbGlkYXRpb24gPSAoaXNCbHVyRXZlbnQsIGlzVG91Y2hlZCwgaXNTdWJtaXR0ZWQsIHJlVmFsaWRhdGVNb2RlLCBtb2RlKSA9PiB7XG4gICAgaWYgKG1vZGUuaXNPbkFsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc1N1Ym1pdHRlZCAmJiBtb2RlLmlzT25Ub3VjaCkge1xuICAgICAgICByZXR1cm4gIShpc1RvdWNoZWQgfHwgaXNCbHVyRXZlbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IHJlVmFsaWRhdGVNb2RlLmlzT25CbHVyIDogbW9kZS5pc09uQmx1cikge1xuICAgICAgICByZXR1cm4gIWlzQmx1ckV2ZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IHJlVmFsaWRhdGVNb2RlLmlzT25DaGFuZ2UgOiBtb2RlLmlzT25DaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGlzQmx1ckV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciB1bnNldEVtcHR5QXJyYXkgPSAocmVmLCBuYW1lKSA9PiAhY29tcGFjdChnZXQocmVmLCBuYW1lKSkubGVuZ3RoICYmIHVuc2V0KHJlZiwgbmFtZSk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcbiAgICByZVZhbGlkYXRlTW9kZTogVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlLFxuICAgIHNob3VsZEZvY3VzRXJyb3I6IHRydWUsXG59O1xuZnVuY3Rpb24gY3JlYXRlRm9ybUNvbnRyb2wocHJvcHMgPSB7fSwgZmx1c2hSb290UmVuZGVyKSB7XG4gICAgbGV0IF9vcHRpb25zID0ge1xuICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgfTtcbiAgICBsZXQgX2Zvcm1TdGF0ZSA9IHtcbiAgICAgICAgc3VibWl0Q291bnQ6IDAsXG4gICAgICAgIGlzRGlydHk6IGZhbHNlLFxuICAgICAgICBpc0xvYWRpbmc6IGlzRnVuY3Rpb24oX29wdGlvbnMuZGVmYXVsdFZhbHVlcyksXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0dGVkOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IHt9LFxuICAgICAgICBkaXJ0eUZpZWxkczoge30sXG4gICAgICAgIGVycm9yczoge30sXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICB9O1xuICAgIGxldCBfZmllbGRzID0ge307XG4gICAgbGV0IF9kZWZhdWx0VmFsdWVzID0gaXNPYmplY3QoX29wdGlvbnMuZGVmYXVsdFZhbHVlcykgfHwgaXNPYmplY3QoX29wdGlvbnMudmFsdWVzKVxuICAgICAgICA/IGNsb25lT2JqZWN0KF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMgfHwgX29wdGlvbnMudmFsdWVzKSB8fCB7fVxuICAgICAgICA6IHt9O1xuICAgIGxldCBfZm9ybVZhbHVlcyA9IF9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXJcbiAgICAgICAgPyB7fVxuICAgICAgICA6IGNsb25lT2JqZWN0KF9kZWZhdWx0VmFsdWVzKTtcbiAgICBsZXQgX3N0YXRlID0ge1xuICAgICAgICBhY3Rpb246IGZhbHNlLFxuICAgICAgICBtb3VudDogZmFsc2UsXG4gICAgICAgIHdhdGNoOiBmYWxzZSxcbiAgICB9O1xuICAgIGxldCBfbmFtZXMgPSB7XG4gICAgICAgIG1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgIHVuTW91bnQ6IG5ldyBTZXQoKSxcbiAgICAgICAgYXJyYXk6IG5ldyBTZXQoKSxcbiAgICAgICAgd2F0Y2g6IG5ldyBTZXQoKSxcbiAgICB9O1xuICAgIGxldCBkZWxheUVycm9yQ2FsbGJhY2s7XG4gICAgbGV0IHRpbWVyID0gMDtcbiAgICBjb25zdCBfcHJveHlGb3JtU3RhdGUgPSB7XG4gICAgICAgIGlzRGlydHk6IGZhbHNlLFxuICAgICAgICBkaXJ0eUZpZWxkczogZmFsc2UsXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IF9zdWJqZWN0cyA9IHtcbiAgICAgICAgdmFsdWVzOiBjcmVhdGVTdWJqZWN0KCksXG4gICAgICAgIGFycmF5OiBjcmVhdGVTdWJqZWN0KCksXG4gICAgICAgIHN0YXRlOiBjcmVhdGVTdWJqZWN0KCksXG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRDYXB0dXJlRGlydHlGaWVsZHMgPSBwcm9wcy5yZXNldE9wdGlvbnMgJiYgcHJvcHMucmVzZXRPcHRpb25zLmtlZXBEaXJ0eVZhbHVlcztcbiAgICBjb25zdCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5tb2RlKTtcbiAgICBjb25zdCB2YWxpZGF0aW9uTW9kZUFmdGVyU3VibWl0ID0gZ2V0VmFsaWRhdGlvbk1vZGVzKF9vcHRpb25zLnJlVmFsaWRhdGVNb2RlKTtcbiAgICBjb25zdCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycyA9IF9vcHRpb25zLmNyaXRlcmlhTW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbDtcbiAgICBjb25zdCBkZWJvdW5jZSA9IChjYWxsYmFjaykgPT4gKHdhaXQpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCB3YWl0KTtcbiAgICB9O1xuICAgIGNvbnN0IF91cGRhdGVWYWxpZCA9IGFzeW5jIChzaG91bGRVcGRhdGVWYWxpZCkgPT4ge1xuICAgICAgICBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHwgc2hvdWxkVXBkYXRlVmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSBfb3B0aW9ucy5yZXNvbHZlclxuICAgICAgICAgICAgICAgID8gaXNFbXB0eU9iamVjdCgoYXdhaXQgX2V4ZWN1dGVTY2hlbWEoKSkuZXJyb3JzKVxuICAgICAgICAgICAgICAgIDogYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQgIT09IF9mb3JtU3RhdGUuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3VwZGF0ZUlzVmFsaWRhdGluZyA9ICh2YWx1ZSkgPT4gX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWRhdGluZyAmJlxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHZhbHVlLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBfdXBkYXRlRmllbGRBcnJheSA9IChuYW1lLCB2YWx1ZXMgPSBbXSwgbWV0aG9kLCBhcmdzLCBzaG91bGRTZXRWYWx1ZXMgPSB0cnVlLCBzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSA9IHRydWUpID0+IHtcbiAgICAgICAgaWYgKGFyZ3MgJiYgbWV0aG9kKSB7XG4gICAgICAgICAgICBfc3RhdGUuYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJiBBcnJheS5pc0FycmF5KGdldChfZmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IG1ldGhvZChnZXQoX2ZpZWxkcywgbmFtZSksIGFyZ3MuYXJnQSwgYXJncy5hcmdCKTtcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRWYWx1ZXMgJiYgc2V0KF9maWVsZHMsIG5hbWUsIGZpZWxkVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBtZXRob2QoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgdW5zZXRFbXB0eUFycmF5KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaGVkRmllbGRzID0gbWV0aG9kKGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUsIHRvdWNoZWRGaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcykge1xuICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuZGlydHlGaWVsZHMgPSBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgaXNEaXJ0eTogX2dldERpcnR5KG5hbWUsIHZhbHVlcyksXG4gICAgICAgICAgICAgICAgZGlydHlGaWVsZHM6IF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiBfZm9ybVN0YXRlLmlzVmFsaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRXJyb3JzID0gKG5hbWUsIGVycm9yKSA9PiB7XG4gICAgICAgIHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZVZhbGlkQW5kVmFsdWUgPSAobmFtZSwgc2hvdWxkU2tpcFNldFZhbHVlQXMsIHZhbHVlLCByZWYpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZ2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBpc1VuZGVmaW5lZCh2YWx1ZSkgPyBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpIDogdmFsdWUpO1xuICAgICAgICAgICAgaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChyZWYgJiYgcmVmLmRlZmF1bHRDaGVja2VkKSB8fFxuICAgICAgICAgICAgICAgIHNob3VsZFNraXBTZXRWYWx1ZUFzXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHNob3VsZFNraXBTZXRWYWx1ZUFzID8gZGVmYXVsdFZhbHVlIDogZ2V0RmllbGRWYWx1ZShmaWVsZC5fZikpXG4gICAgICAgICAgICAgICAgOiBzZXRGaWVsZFZhbHVlKG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICBfc3RhdGUubW91bnQgJiYgX3VwZGF0ZVZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZVRvdWNoQW5kRGlydHkgPSAobmFtZSwgZmllbGRWYWx1ZSwgaXNCbHVyRXZlbnQsIHNob3VsZERpcnR5LCBzaG91bGRSZW5kZXIpID0+IHtcbiAgICAgICAgbGV0IHNob3VsZFVwZGF0ZUZpZWxkID0gZmFsc2U7XG4gICAgICAgIGxldCBpc1ByZXZpb3VzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpc0JsdXJFdmVudCB8fCBzaG91bGREaXJ0eSkge1xuICAgICAgICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgaXNQcmV2aW91c0RpcnR5ID0gX2Zvcm1TdGF0ZS5pc0RpcnR5O1xuICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuaXNEaXJ0eSA9IG91dHB1dC5pc0RpcnR5ID0gX2dldERpcnR5KCk7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPSBpc1ByZXZpb3VzRGlydHkgIT09IG91dHB1dC5pc0RpcnR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50RmllbGRQcmlzdGluZSA9IGRlZXBFcXVhbChnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGlzUHJldmlvdXNEaXJ0eSA9IGdldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgIGlzQ3VycmVudEZpZWxkUHJpc3RpbmVcbiAgICAgICAgICAgICAgICA/IHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpXG4gICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICBvdXRwdXQuZGlydHlGaWVsZHMgPSBfZm9ybVN0YXRlLmRpcnR5RmllbGRzO1xuICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPVxuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkIHx8XG4gICAgICAgICAgICAgICAgICAgIChfcHJveHlGb3JtU3RhdGUuZGlydHlGaWVsZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJldmlvdXNEaXJ0eSAhPT0gIWlzQ3VycmVudEZpZWxkUHJpc3RpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgY29uc3QgaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCA9IGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFpc1ByZXZpb3VzRmllbGRUb3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSwgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC50b3VjaGVkRmllbGRzID0gX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzO1xuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkID1cbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJldmlvdXNGaWVsZFRvdWNoZWQgIT09IGlzQmx1ckV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCAmJiBzaG91bGRSZW5kZXIgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZUZpZWxkID8gb3V0cHV0IDoge307XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRSZW5kZXJCeUVycm9yID0gKG5hbWUsIGlzVmFsaWQsIGVycm9yLCBmaWVsZFN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRmllbGRFcnJvciA9IGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZVZhbGlkID0gX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgJiZcbiAgICAgICAgICAgIGlzQm9vbGVhbihpc1ZhbGlkKSAmJlxuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc1ZhbGlkICE9PSBpc1ZhbGlkO1xuICAgICAgICBpZiAocHJvcHMuZGVsYXlFcnJvciAmJiBlcnJvcikge1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gZGVib3VuY2UoKCkgPT4gdXBkYXRlRXJyb3JzKG5hbWUsIGVycm9yKSk7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2socHJvcHMuZGVsYXlFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZXJyb3IgPyAhZGVlcEVxdWFsKHByZXZpb3VzRmllbGRFcnJvciwgZXJyb3IpIDogcHJldmlvdXNGaWVsZEVycm9yKSB8fFxuICAgICAgICAgICAgIWlzRW1wdHlPYmplY3QoZmllbGRTdGF0ZSkgfHxcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZVZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4uKHNob3VsZFVwZGF0ZVZhbGlkICYmIGlzQm9vbGVhbihpc1ZhbGlkKSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfZm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh1cGRhdGVkRm9ybVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IF9leGVjdXRlU2NoZW1hID0gYXN5bmMgKG5hbWUpID0+IF9vcHRpb25zLnJlc29sdmVyKF9mb3JtVmFsdWVzLCBfb3B0aW9ucy5jb250ZXh0LCBnZXRSZXNvbHZlck9wdGlvbnMobmFtZSB8fCBfbmFtZXMubW91bnQsIF9maWVsZHMsIF9vcHRpb25zLmNyaXRlcmlhTW9kZSwgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikpO1xuICAgIGNvbnN0IGV4ZWN1dGVTY2hlbWFBbmRVcGRhdGVTdGF0ZSA9IGFzeW5jIChuYW1lcykgPT4ge1xuICAgICAgICBjb25zdCB7IGVycm9ycyB9ID0gYXdhaXQgX2V4ZWN1dGVTY2hlbWEobmFtZXMpO1xuICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICA6IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24gPSBhc3luYyAoZmllbGRzLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCA9IHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgfSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgX2YsIC4uLmZpZWxkVmFsdWUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIGlmIChfZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXlSb290ID0gX25hbWVzLmFycmF5LmhhcyhfZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRFcnJvciA9IGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGQsIF9mb3JtVmFsdWVzLCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycywgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiAmJiAhc2hvdWxkT25seUNoZWNrVmFsaWQsIGlzRmllbGRBcnJheVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRFcnJvcltfZi5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZE9ubHlDaGVja1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIXNob3VsZE9ubHlDaGVja1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZ2V0KGZpZWxkRXJyb3IsIF9mLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpc0ZpZWxkQXJyYXlSb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvcihfZm9ybVN0YXRlLmVycm9ycywgZmllbGRFcnJvciwgX2YubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUsIGZpZWxkRXJyb3JbX2YubmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgX2YubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIChhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oZmllbGRWYWx1ZSwgc2hvdWxkT25seUNoZWNrVmFsaWQsIGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dC52YWxpZDtcbiAgICB9O1xuICAgIGNvbnN0IF9yZW1vdmVVbm1vdW50ZWQgPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBfbmFtZXMudW5Nb3VudCkge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICBmaWVsZCAmJlxuICAgICAgICAgICAgICAgIChmaWVsZC5fZi5yZWZzXG4gICAgICAgICAgICAgICAgICAgID8gZmllbGQuX2YucmVmcy5ldmVyeSgocmVmKSA9PiAhbGl2ZShyZWYpKVxuICAgICAgICAgICAgICAgICAgICA6ICFsaXZlKGZpZWxkLl9mLnJlZikpICYmXG4gICAgICAgICAgICAgICAgdW5yZWdpc3RlcihuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBfbmFtZXMudW5Nb3VudCA9IG5ldyBTZXQoKTtcbiAgICB9O1xuICAgIGNvbnN0IF9nZXREaXJ0eSA9IChuYW1lLCBkYXRhKSA9PiAobmFtZSAmJiBkYXRhICYmIHNldChfZm9ybVZhbHVlcywgbmFtZSwgZGF0YSksXG4gICAgICAgICFkZWVwRXF1YWwoZ2V0VmFsdWVzKCksIF9kZWZhdWx0VmFsdWVzKSk7XG4gICAgY29uc3QgX2dldFdhdGNoID0gKG5hbWVzLCBkZWZhdWx0VmFsdWUsIGlzR2xvYmFsKSA9PiBnZW5lcmF0ZVdhdGNoT3V0cHV0KG5hbWVzLCBfbmFtZXMsIHtcbiAgICAgICAgLi4uKF9zdGF0ZS5tb3VudFxuICAgICAgICAgICAgPyBfZm9ybVZhbHVlc1xuICAgICAgICAgICAgOiBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgPyBfZGVmYXVsdFZhbHVlc1xuICAgICAgICAgICAgICAgIDogaXNTdHJpbmcobmFtZXMpXG4gICAgICAgICAgICAgICAgICAgID8geyBbbmFtZXNdOiBkZWZhdWx0VmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZSksXG4gICAgfSwgaXNHbG9iYWwsIGRlZmF1bHRWYWx1ZSk7XG4gICAgY29uc3QgX2dldEZpZWxkQXJyYXkgPSAobmFtZSkgPT4gY29tcGFjdChnZXQoX3N0YXRlLm1vdW50ID8gX2Zvcm1WYWx1ZXMgOiBfZGVmYXVsdFZhbHVlcywgbmFtZSwgcHJvcHMuc2hvdWxkVW5yZWdpc3RlciA/IGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSwgW10pIDogW10pKTtcbiAgICBjb25zdCBzZXRGaWVsZFZhbHVlID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGxldCBmaWVsZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZC5fZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICFmaWVsZFJlZmVyZW5jZS5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldEZpZWxkVmFsdWVBcyh2YWx1ZSwgZmllbGRSZWZlcmVuY2UpKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZS5yZWYpICYmIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNdWx0aXBsZVNlbGVjdChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIFsuLi5maWVsZFJlZmVyZW5jZS5yZWYub3B0aW9uc10uZm9yRWFjaCgob3B0aW9uUmVmKSA9PiAob3B0aW9uUmVmLnNlbGVjdGVkID0gZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25SZWYudmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkUmVmZXJlbmNlLnJlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tCb3hJbnB1dChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWZzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZpZWxkUmVmZXJlbmNlLnJlZnMuZm9yRWFjaCgoY2hlY2tib3hSZWYpID0+ICghY2hlY2tib3hSZWYuZGVmYXVsdENoZWNrZWQgfHwgIWNoZWNrYm94UmVmLmRpc2FibGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hlY2tib3hSZWYuY2hlY2tlZCA9IEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gISFmaWVsZFZhbHVlLmZpbmQoKGRhdGEpID0+IGRhdGEgPT09IGNoZWNrYm94UmVmLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZFZhbHVlID09PSBjaGVja2JveFJlZi52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZFJlZmVyZW5jZS5yZWZzWzBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWVsZFJlZmVyZW5jZS5yZWZzWzBdLmNoZWNrZWQgPSAhIWZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmcy5mb3JFYWNoKChyYWRpb1JlZikgPT4gKHJhZGlvUmVmLmNoZWNrZWQgPSByYWRpb1JlZi52YWx1ZSA9PT0gZmllbGRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlsZUlucHV0KGZpZWxkUmVmZXJlbmNlLnJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWYudmFsdWUgPSBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkUmVmZXJlbmNlLnJlZi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAob3B0aW9ucy5zaG91bGREaXJ0eSB8fCBvcHRpb25zLnNob3VsZFRvdWNoKSAmJlxuICAgICAgICAgICAgdXBkYXRlVG91Y2hBbmREaXJ0eShuYW1lLCBmaWVsZFZhbHVlLCBvcHRpb25zLnNob3VsZFRvdWNoLCBvcHRpb25zLnNob3VsZERpcnR5LCB0cnVlKTtcbiAgICAgICAgb3B0aW9ucy5zaG91bGRWYWxpZGF0ZSAmJiB0cmlnZ2VyKG5hbWUpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0VmFsdWVzID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRLZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSB2YWx1ZVtmaWVsZEtleV07XG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBgJHtuYW1lfS4ke2ZpZWxkS2V5fWA7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgKF9uYW1lcy5hcnJheS5oYXMobmFtZSkgfHxcbiAgICAgICAgICAgICAgICAhaXNQcmltaXRpdmUoZmllbGRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAoZmllbGQgJiYgIWZpZWxkLl9mKSkgJiZcbiAgICAgICAgICAgICAgICAhaXNEYXRlT2JqZWN0KGZpZWxkVmFsdWUpXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZXMoZmllbGROYW1lLCBmaWVsZFZhbHVlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXkgPSBfbmFtZXMuYXJyYXkuaGFzKG5hbWUpO1xuICAgICAgICBjb25zdCBjbG9uZVZhbHVlID0gY2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGNsb25lVmFsdWUpO1xuICAgICAgICBpZiAoaXNGaWVsZEFycmF5KSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuYXJyYXkubmV4dCh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4uX2Zvcm1WYWx1ZXMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKChfcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSB8fCBfcHJveHlGb3JtU3RhdGUuZGlydHlGaWVsZHMpICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGREaXJ0eSkge1xuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlydHlGaWVsZHM6IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcyksXG4gICAgICAgICAgICAgICAgICAgIGlzRGlydHk6IF9nZXREaXJ0eShuYW1lLCBjbG9uZVZhbHVlKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkICYmICFmaWVsZC5fZiAmJiAhaXNOdWxsT3JVbmRlZmluZWQoY2xvbmVWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlcyhuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpc1dhdGNoZWQobmFtZSwgX25hbWVzKSAmJiBfc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIF9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAhX3N0YXRlLm1vdW50ICYmIGZsdXNoUm9vdFJlbmRlcigpO1xuICAgIH07XG4gICAgY29uc3Qgb25DaGFuZ2UgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBsZXQgbmFtZSA9IHRhcmdldC5uYW1lO1xuICAgICAgICBsZXQgaXNGaWVsZFZhbHVlVXBkYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBjb25zdCBnZXRDdXJyZW50RmllbGRWYWx1ZSA9ICgpID0+IHRhcmdldC50eXBlID8gZ2V0RmllbGRWYWx1ZShmaWVsZC5fZikgOiBnZXRFdmVudFZhbHVlKGV2ZW50KTtcbiAgICAgICAgY29uc3QgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQgPSAoZmllbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaXNGaWVsZFZhbHVlVXBkYXRlZCA9XG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzTmFOKGZpZWxkVmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPT09IGdldChfZm9ybVZhbHVlcywgbmFtZSwgZmllbGRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gZ2V0Q3VycmVudEZpZWxkVmFsdWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzQmx1ckV2ZW50ID0gZXZlbnQudHlwZSA9PT0gRVZFTlRTLkJMVVIgfHwgZXZlbnQudHlwZSA9PT0gRVZFTlRTLkZPQ1VTX09VVDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNraXBWYWxpZGF0aW9uID0gKCFoYXNWYWxpZGF0aW9uKGZpZWxkLl9mKSAmJlxuICAgICAgICAgICAgICAgICFfb3B0aW9ucy5yZXNvbHZlciAmJlxuICAgICAgICAgICAgICAgICFnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICAgIWZpZWxkLl9mLmRlcHMpIHx8XG4gICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24oaXNCbHVyRXZlbnQsIGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBfZm9ybVN0YXRlLmlzU3VibWl0dGVkLCB2YWxpZGF0aW9uTW9kZUFmdGVyU3VibWl0LCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCk7XG4gICAgICAgICAgICBjb25zdCB3YXRjaGVkID0gaXNXYXRjaGVkKG5hbWUsIF9uYW1lcywgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLm9uQmx1ciAmJiBmaWVsZC5fZi5vbkJsdXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayAmJiBkZWxheUVycm9yQ2FsbGJhY2soMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5fZi5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLm9uQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU3RhdGUgPSB1cGRhdGVUb3VjaEFuZERpcnR5KG5hbWUsIGZpZWxkVmFsdWUsIGlzQmx1ckV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZW5kZXIgPSAhaXNFbXB0eU9iamVjdChmaWVsZFN0YXRlKSB8fCB3YXRjaGVkO1xuICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmXG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZXZlbnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICBfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCAmJiBfdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNob3VsZFJlbmRlciAmJlxuICAgICAgICAgICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7IG5hbWUsIC4uLih3YXRjaGVkID8ge30gOiBmaWVsZFN0YXRlKSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhaXNCbHVyRXZlbnQgJiYgd2F0Y2hlZCAmJiBfc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKHRydWUpO1xuICAgICAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9leGVjdXRlU2NoZW1hKFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNFcnJvckxvb2t1cFJlc3VsdCA9IHNjaGVtYUVycm9yTG9va3VwKF9mb3JtU3RhdGUuZXJyb3JzLCBfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JMb29rdXBSZXN1bHQgPSBzY2hlbWFFcnJvckxvb2t1cChlcnJvcnMsIF9maWVsZHMsIHByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQubmFtZSB8fCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvckxvb2t1cFJlc3VsdC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGVycm9yTG9va3VwUmVzdWx0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAoYXdhaXQgdmFsaWRhdGVGaWVsZChmaWVsZCwgX2Zvcm1WYWx1ZXMsIHNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzLCBfb3B0aW9ucy5zaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSlbbmFtZV07XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNGaWVsZFZhbHVlVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLmRlcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcihmaWVsZC5fZi5kZXBzKTtcbiAgICAgICAgICAgICAgICBzaG91bGRSZW5kZXJCeUVycm9yKG5hbWUsIGlzVmFsaWQsIGVycm9yLCBmaWVsZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX2ZvY3VzSW5wdXQgPSAocmVmLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGdldChfZm9ybVN0YXRlLmVycm9ycywga2V5KSAmJiByZWYuZm9jdXMpIHtcbiAgICAgICAgICAgIHJlZi5mb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgY29uc3QgdHJpZ2dlciA9IGFzeW5jIChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0O1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpO1xuICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKHRydWUpO1xuICAgICAgICBpZiAoX29wdGlvbnMucmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGF3YWl0IGV4ZWN1dGVTY2hlbWFBbmRVcGRhdGVTdGF0ZShpc1VuZGVmaW5lZChuYW1lKSA/IG5hbWUgOiBmaWVsZE5hbWVzKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gbmFtZVxuICAgICAgICAgICAgICAgID8gIWZpZWxkTmFtZXMuc29tZSgobmFtZSkgPT4gZ2V0KGVycm9ycywgbmFtZSkpXG4gICAgICAgICAgICAgICAgOiBpc1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSAoYXdhaXQgUHJvbWlzZS5hbGwoZmllbGROYW1lcy5tYXAoYXN5bmMgKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihmaWVsZCAmJiBmaWVsZC5fZiA/IHsgW2ZpZWxkTmFtZV06IGZpZWxkIH0gOiBmaWVsZCk7XG4gICAgICAgICAgICB9KSkpLmV2ZXJ5KEJvb2xlYW4pO1xuICAgICAgICAgICAgISghdmFsaWRhdGlvblJlc3VsdCAmJiAhX2Zvcm1TdGF0ZS5pc1ZhbGlkKSAmJiBfdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMpO1xuICAgICAgICB9XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIC4uLighaXNTdHJpbmcobmFtZSkgfHxcbiAgICAgICAgICAgICAgICAoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgJiYgaXNWYWxpZCAhPT0gX2Zvcm1TdGF0ZS5pc1ZhbGlkKVxuICAgICAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgICAgICA6IHsgbmFtZSB9KSxcbiAgICAgICAgICAgIC4uLihfb3B0aW9ucy5yZXNvbHZlciB8fCAhbmFtZSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLnNob3VsZEZvY3VzICYmXG4gICAgICAgICAgICAhdmFsaWRhdGlvblJlc3VsdCAmJlxuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKF9maWVsZHMsIF9mb2N1c0lucHV0LCBuYW1lID8gZmllbGROYW1lcyA6IF9uYW1lcy5tb3VudCk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0O1xuICAgIH07XG4gICAgY29uc3QgZ2V0VmFsdWVzID0gKGZpZWxkTmFtZXMpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgICAgICAgLi4uX2RlZmF1bHRWYWx1ZXMsXG4gICAgICAgICAgICAuLi4oX3N0YXRlLm1vdW50ID8gX2Zvcm1WYWx1ZXMgOiB7fSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChmaWVsZE5hbWVzKVxuICAgICAgICAgICAgPyB2YWx1ZXNcbiAgICAgICAgICAgIDogaXNTdHJpbmcoZmllbGROYW1lcylcbiAgICAgICAgICAgICAgICA/IGdldCh2YWx1ZXMsIGZpZWxkTmFtZXMpXG4gICAgICAgICAgICAgICAgOiBmaWVsZE5hbWVzLm1hcCgobmFtZSkgPT4gZ2V0KHZhbHVlcywgbmFtZSkpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0RmllbGRTdGF0ZSA9IChuYW1lLCBmb3JtU3RhdGUpID0+ICh7XG4gICAgICAgIGludmFsaWQ6ICEhZ2V0KChmb3JtU3RhdGUgfHwgX2Zvcm1TdGF0ZSkuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgaXNEaXJ0eTogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5kaXJ0eUZpZWxkcywgbmFtZSksXG4gICAgICAgIGlzVG91Y2hlZDogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICAgICAgZXJyb3I6IGdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmVycm9ycywgbmFtZSksXG4gICAgfSk7XG4gICAgY29uc3QgY2xlYXJFcnJvcnMgPSAobmFtZSkgPT4ge1xuICAgICAgICBuYW1lICYmXG4gICAgICAgICAgICBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkuZm9yRWFjaCgoaW5wdXROYW1lKSA9PiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgaW5wdXROYW1lKSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGVycm9yczogbmFtZSA/IF9mb3JtU3RhdGUuZXJyb3JzIDoge30sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0RXJyb3IgPSAobmFtZSwgZXJyb3IsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgcmVmID0gKGdldChfZmllbGRzLCBuYW1lLCB7IF9mOiB7fSB9KS5fZiB8fCB7fSkucmVmO1xuICAgICAgICBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIHtcbiAgICAgICAgICAgIC4uLmVycm9yLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zaG91bGRGb2N1cyAmJiByZWYgJiYgcmVmLmZvY3VzICYmIHJlZi5mb2N1cygpO1xuICAgIH07XG4gICAgY29uc3Qgd2F0Y2ggPSAobmFtZSwgZGVmYXVsdFZhbHVlKSA9PiBpc0Z1bmN0aW9uKG5hbWUpXG4gICAgICAgID8gX3N1YmplY3RzLnZhbHVlcy5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogKHBheWxvYWQpID0+IG5hbWUoX2dldFdhdGNoKHVuZGVmaW5lZCwgZGVmYXVsdFZhbHVlKSwgcGF5bG9hZCksXG4gICAgICAgIH0pXG4gICAgICAgIDogX2dldFdhdGNoKG5hbWUsIGRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgY29uc3QgdW5yZWdpc3RlciA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgbmFtZSA/IGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKSA6IF9uYW1lcy5tb3VudCkge1xuICAgICAgICAgICAgX25hbWVzLm1vdW50LmRlbGV0ZShmaWVsZE5hbWUpO1xuICAgICAgICAgICAgX25hbWVzLmFycmF5LmRlbGV0ZShmaWVsZE5hbWUpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9maWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1WYWx1ZXMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwRXJyb3IgJiYgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwRGlydHkgJiYgdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICFvcHRpb25zLmtlZXBUb3VjaGVkICYmIHVuc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgICFfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyICYmXG4gICAgICAgICAgICAgICAgIW9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgIHVuc2V0KF9kZWZhdWx0VmFsdWVzLCBmaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIF9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XG4gICAgICAgICAgICB2YWx1ZXM6IHsgLi4uX2Zvcm1WYWx1ZXMgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAuLi4oIW9wdGlvbnMua2VlcERpcnR5ID8ge30gOiB7IGlzRGlydHk6IF9nZXREaXJ0eSgpIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgIW9wdGlvbnMua2VlcElzVmFsaWQgJiYgX3VwZGF0ZVZhbGlkKCk7XG4gICAgfTtcbiAgICBjb25zdCBfdXBkYXRlRGlzYWJsZWRGaWVsZCA9ICh7IGRpc2FibGVkLCBuYW1lLCBmaWVsZCwgZmllbGRzLCB2YWx1ZSwgfSkgPT4ge1xuICAgICAgICBpZiAoaXNCb29sZWFuKGRpc2FibGVkKSkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRWYWx1ZSA9IGRpc2FibGVkXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IGlzVW5kZWZpbmVkKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IGdldEZpZWxkVmFsdWUoZmllbGQgPyBmaWVsZC5fZiA6IGdldChmaWVsZHMsIG5hbWUpLl9mKVxuICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIHVwZGF0ZVRvdWNoQW5kRGlydHkobmFtZSwgaW5wdXRWYWx1ZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGxldCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZGlzYWJsZWRJc0RlZmluZWQgPSBpc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlZCk7XG4gICAgICAgIHNldChfZmllbGRzLCBuYW1lLCB7XG4gICAgICAgICAgICAuLi4oZmllbGQgfHwge30pLFxuICAgICAgICAgICAgX2Y6IHtcbiAgICAgICAgICAgICAgICAuLi4oZmllbGQgJiYgZmllbGQuX2YgPyBmaWVsZC5fZiA6IHsgcmVmOiB7IG5hbWUgfSB9KSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIG1vdW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgX25hbWVzLm1vdW50LmFkZChuYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBfdXBkYXRlRGlzYWJsZWRGaWVsZCh7XG4gICAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IG9wdGlvbnMuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlVmFsaWRBbmRWYWx1ZShuYW1lLCB0cnVlLCBvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uKGRpc2FibGVkSXNEZWZpbmVkID8geyBkaXNhYmxlZDogb3B0aW9ucy5kaXNhYmxlZCB9IDoge30pLFxuICAgICAgICAgICAgLi4uKF9vcHRpb25zLnByb2dyZXNzaXZlXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhIW9wdGlvbnMucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgICAgIG1pbjogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWluKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBnZXRSdWxlVmFsdWUob3B0aW9ucy5tYXgpLFxuICAgICAgICAgICAgICAgICAgICBtaW5MZW5ndGg6IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1pbkxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIG1heExlbmd0aDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWF4TGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZ2V0UnVsZVZhbHVlKG9wdGlvbnMucGF0dGVybiksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICAgICAgb25CbHVyOiBvbkNoYW5nZSxcbiAgICAgICAgICAgIHJlZjogKHJlZikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXIobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFJlZiA9IGlzVW5kZWZpbmVkKHJlZi52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLnF1ZXJ5U2VsZWN0b3JBbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCxzZWxlY3QsdGV4dGFyZWEnKVswXSB8fCByZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWY7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhZGlvT3JDaGVja2JveCA9IGlzUmFkaW9PckNoZWNrYm94KGZpZWxkUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcyA9IGZpZWxkLl9mLnJlZnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYWRpb09yQ2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmcy5maW5kKChvcHRpb24pID0+IG9wdGlvbiA9PT0gZmllbGRSZWYpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkUmVmID09PSBmaWVsZC5fZi5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQoX2ZpZWxkcywgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Y6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5maWVsZC5fZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4ocmFkaW9PckNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlZnMuZmlsdGVyKGxpdmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkpID8gW3t9XSA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IHsgdHlwZTogZmllbGRSZWYudHlwZSwgbmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeyByZWY6IGZpZWxkUmVmIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbGlkQW5kVmFsdWUobmFtZSwgZmFsc2UsIHVuZGVmaW5lZCwgZmllbGRSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSwge30pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLm1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgfHwgb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIShpc05hbWVJbkZpZWxkQXJyYXkoX25hbWVzLmFycmF5LCBuYW1lKSAmJiBfc3RhdGUuYWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgX25hbWVzLnVuTW91bnQuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBfZm9jdXNFcnJvciA9ICgpID0+IF9vcHRpb25zLnNob3VsZEZvY3VzRXJyb3IgJiZcbiAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKF9maWVsZHMsIF9mb2N1c0lucHV0LCBfbmFtZXMubW91bnQpO1xuICAgIGNvbnN0IF9kaXNhYmxlRm9ybSA9IChkaXNhYmxlZCkgPT4ge1xuICAgICAgICBpZiAoaXNCb29sZWFuKGRpc2FibGVkKSkge1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyBkaXNhYmxlZCB9KTtcbiAgICAgICAgICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihfZmllbGRzLCAocmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVmLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgICAgICB9LCAwLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IChvblZhbGlkLCBvbkludmFsaWQpID0+IGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUucGVyc2lzdCAmJiBlLnBlcnNpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRWYWx1ZXMgPSBjbG9uZU9iamVjdChfZm9ybVZhbHVlcyk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMsIHZhbHVlcyB9ID0gYXdhaXQgX2V4ZWN1dGVTY2hlbWEoKTtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgZmllbGRWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsICdyb290Jyk7XG4gICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUuZXJyb3JzKSkge1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGVycm9yczoge30sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IG9uVmFsaWQoZmllbGRWYWx1ZXMsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9uSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uSW52YWxpZCh7IC4uLl9mb3JtU3RhdGUuZXJyb3JzIH0sIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2ZvY3VzRXJyb3IoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoX2ZvY3VzRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGlzU3VibWl0dGVkOiB0cnVlLFxuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogaXNFbXB0eU9iamVjdChfZm9ybVN0YXRlLmVycm9ycyksXG4gICAgICAgICAgICBzdWJtaXRDb3VudDogX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudCArIDEsXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0RmllbGQgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGlmIChnZXQoX2ZpZWxkcywgbmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChvcHRpb25zLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShuYW1lLCBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFZhbHVlKG5hbWUsIG9wdGlvbnMuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICBzZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIG9wdGlvbnMuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVG91Y2hlZCkge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcERpcnR5KSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc0RpcnR5ID0gb3B0aW9ucy5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgPyBfZ2V0RGlydHkobmFtZSwgZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgOiBfZ2V0RGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgJiYgX3VwZGF0ZVZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9yZXNldCA9IChmb3JtVmFsdWVzLCBrZWVwU3RhdGVPcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFZhbHVlcyA9IGZvcm1WYWx1ZXMgPyBjbG9uZU9iamVjdChmb3JtVmFsdWVzKSA6IF9kZWZhdWx0VmFsdWVzO1xuICAgICAgICBjb25zdCBjbG9uZVVwZGF0ZWRWYWx1ZXMgPSBjbG9uZU9iamVjdCh1cGRhdGVkVmFsdWVzKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZm9ybVZhbHVlcyAmJiAhaXNFbXB0eU9iamVjdChmb3JtVmFsdWVzKVxuICAgICAgICAgICAgPyBjbG9uZVVwZGF0ZWRWYWx1ZXNcbiAgICAgICAgICAgIDogX2RlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGlmICgha2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgX2RlZmF1bHRWYWx1ZXMgPSB1cGRhdGVkVmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2VlcFN0YXRlT3B0aW9ucy5rZWVwVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoa2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXMgfHwgc2hvdWxkQ2FwdHVyZURpcnR5RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgX25hbWVzLm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBmaWVsZE5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNldCh2YWx1ZXMsIGZpZWxkTmFtZSwgZ2V0KF9mb3JtVmFsdWVzLCBmaWVsZE5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXRWYWx1ZShmaWVsZE5hbWUsIGdldCh2YWx1ZXMsIGZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1dlYiAmJiBpc1VuZGVmaW5lZChmb3JtVmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC5fZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gQXJyYXkuaXNBcnJheShmaWVsZC5fZi5yZWZzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZpZWxkLl9mLnJlZnNbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZC5fZi5yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoZmllbGRSZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm0gPSBmaWVsZFJlZmVyZW5jZS5jbG9zZXN0KCdmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZmllbGRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZm9ybVZhbHVlcyA9IHByb3BzLnNob3VsZFVucmVnaXN0ZXJcbiAgICAgICAgICAgICAgICA/IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgPyBjbG9uZU9iamVjdChfZGVmYXVsdFZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgOiB7fVxuICAgICAgICAgICAgICAgIDogY2xvbmVPYmplY3QodmFsdWVzKTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5hcnJheS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4udmFsdWVzIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLnZhbHVlcyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX25hbWVzID0ge1xuICAgICAgICAgICAgbW91bnQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHVuTW91bnQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgICAgICAgICB3YXRjaDogbmV3IFNldCgpLFxuICAgICAgICAgICAgd2F0Y2hBbGw6IGZhbHNlLFxuICAgICAgICAgICAgZm9jdXM6ICcnLFxuICAgICAgICB9O1xuICAgICAgICAhX3N0YXRlLm1vdW50ICYmIGZsdXNoUm9vdFJlbmRlcigpO1xuICAgICAgICBfc3RhdGUubW91bnQgPSAhX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHwgISFrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1ZhbGlkO1xuICAgICAgICBfc3RhdGUud2F0Y2ggPSAhIXByb3BzLnNob3VsZFVucmVnaXN0ZXI7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIHN1Ym1pdENvdW50OiBrZWVwU3RhdGVPcHRpb25zLmtlZXBTdWJtaXRDb3VudFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudFxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGlzRGlydHk6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5XG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzRGlydHlcbiAgICAgICAgICAgICAgICA6ICEhKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgIWRlZXBFcXVhbChmb3JtVmFsdWVzLCBfZGVmYXVsdFZhbHVlcykpLFxuICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcElzU3VibWl0dGVkXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzU3VibWl0dGVkXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGRpcnR5RmllbGRzOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlc1xuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkc1xuICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcyAmJiBmb3JtVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIGZvcm1WYWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICB0b3VjaGVkRmllbGRzOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBUb3VjaGVkXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHNcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgZXJyb3JzOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBFcnJvcnMgPyBfZm9ybVN0YXRlLmVycm9ycyA6IHt9LFxuICAgICAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1N1Ym1pdFN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuaXNTdWJtaXRTdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucykgPT4gX3Jlc2V0KGlzRnVuY3Rpb24oZm9ybVZhbHVlcylcbiAgICAgICAgPyBmb3JtVmFsdWVzKF9mb3JtVmFsdWVzKVxuICAgICAgICA6IGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMpO1xuICAgIGNvbnN0IHNldEZvY3VzID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZCAmJiBmaWVsZC5fZjtcbiAgICAgICAgaWYgKGZpZWxkUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFJlZiA9IGZpZWxkUmVmZXJlbmNlLnJlZnNcbiAgICAgICAgICAgICAgICA/IGZpZWxkUmVmZXJlbmNlLnJlZnNbMF1cbiAgICAgICAgICAgICAgICA6IGZpZWxkUmVmZXJlbmNlLnJlZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZi5mb2N1cykge1xuICAgICAgICAgICAgICAgIGZpZWxkUmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGRTZWxlY3QgJiYgZmllbGRSZWYuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF91cGRhdGVGb3JtU3RhdGUgPSAodXBkYXRlZEZvcm1TdGF0ZSkgPT4ge1xuICAgICAgICBfZm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgIC4uLnVwZGF0ZWRGb3JtU3RhdGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBfcmVzZXREZWZhdWx0VmFsdWVzID0gKCkgPT4gaXNGdW5jdGlvbihfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKSAmJlxuICAgICAgICBfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKCkudGhlbigodmFsdWVzKSA9PiB7XG4gICAgICAgICAgICByZXNldCh2YWx1ZXMsIF9vcHRpb25zLnJlc2V0T3B0aW9ucyk7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICByZWdpc3RlcixcbiAgICAgICAgICAgIHVucmVnaXN0ZXIsXG4gICAgICAgICAgICBnZXRGaWVsZFN0YXRlLFxuICAgICAgICAgICAgaGFuZGxlU3VibWl0LFxuICAgICAgICAgICAgc2V0RXJyb3IsXG4gICAgICAgICAgICBfZXhlY3V0ZVNjaGVtYSxcbiAgICAgICAgICAgIF9nZXRXYXRjaCxcbiAgICAgICAgICAgIF9nZXREaXJ0eSxcbiAgICAgICAgICAgIF91cGRhdGVWYWxpZCxcbiAgICAgICAgICAgIF9yZW1vdmVVbm1vdW50ZWQsXG4gICAgICAgICAgICBfdXBkYXRlRmllbGRBcnJheSxcbiAgICAgICAgICAgIF91cGRhdGVEaXNhYmxlZEZpZWxkLFxuICAgICAgICAgICAgX2dldEZpZWxkQXJyYXksXG4gICAgICAgICAgICBfcmVzZXQsXG4gICAgICAgICAgICBfcmVzZXREZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgX3VwZGF0ZUZvcm1TdGF0ZSxcbiAgICAgICAgICAgIF9kaXNhYmxlRm9ybSxcbiAgICAgICAgICAgIF9zdWJqZWN0cyxcbiAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZSxcbiAgICAgICAgICAgIGdldCBfZmllbGRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZmllbGRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfZm9ybVZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zvcm1WYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9zdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBfc3RhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX2RlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kZWZhdWx0VmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfbmFtZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX25hbWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX25hbWVzID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9mb3JtU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JtU3RhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IF9mb3JtU3RhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9vcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb3B0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX29wdGlvbnModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyLFxuICAgICAgICByZWdpc3RlcixcbiAgICAgICAgaGFuZGxlU3VibWl0LFxuICAgICAgICB3YXRjaCxcbiAgICAgICAgc2V0VmFsdWUsXG4gICAgICAgIGdldFZhbHVlcyxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIHJlc2V0RmllbGQsXG4gICAgICAgIGNsZWFyRXJyb3JzLFxuICAgICAgICB1bnJlZ2lzdGVyLFxuICAgICAgICBzZXRFcnJvcixcbiAgICAgICAgc2V0Rm9jdXMsXG4gICAgICAgIGdldEZpZWxkU3RhdGUsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byBtYW5hZ2UgdGhlIGVudGlyZSBmb3JtLlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tZ2V0LXN0YXJ0ZWQtdHMtNWtzbW0pIOKAoiBbVmlkZW9dKGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9UmtYdjRBWFhDXzQpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gZm9ybSBjb25maWd1cmF0aW9uIGFuZCB2YWxpZGF0aW9uIHBhcmFtZXRlcnMuXG4gKlxuICogQHJldHVybnMgbWV0aG9kcyAtIGluZGl2aWR1YWwgZnVuY3Rpb25zIHRvIG1hbmFnZSB0aGUgZm9ybSBzdGF0ZS4ge0BsaW5rIFVzZUZvcm1SZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBoYW5kbGVTdWJtaXQsIHdhdGNoLCBmb3JtU3RhdGU6IHsgZXJyb3JzIH0gfSA9IHVzZUZvcm0oKTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgY29uc29sZS5sb2cod2F0Y2goXCJleGFtcGxlXCIpKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgPGlucHV0IGRlZmF1bHRWYWx1ZT1cInRlc3RcIiB7Li4ucmVnaXN0ZXIoXCJleGFtcGxlXCIpfSAvPlxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcImV4YW1wbGVSZXF1aXJlZFwiLCB7IHJlcXVpcmVkOiB0cnVlIH0pfSAvPlxuICogICAgICAge2Vycm9ycy5leGFtcGxlUmVxdWlyZWQgJiYgPHNwYW4+VGhpcyBmaWVsZCBpcyByZXF1aXJlZDwvc3Bhbj59XG4gKiAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGb3JtKHByb3BzID0ge30pIHtcbiAgICBjb25zdCBfZm9ybUNvbnRyb2wgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBjb25zdCBfdmFsdWVzID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogaXNGdW5jdGlvbihwcm9wcy5kZWZhdWx0VmFsdWVzKSxcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgc3VibWl0Q291bnQ6IDAsXG4gICAgICAgIGRpcnR5RmllbGRzOiB7fSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczoge30sXG4gICAgICAgIGVycm9yczoge30sXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlczogaXNGdW5jdGlvbihwcm9wcy5kZWZhdWx0VmFsdWVzKVxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogcHJvcHMuZGVmYXVsdFZhbHVlcyxcbiAgICB9KTtcbiAgICBpZiAoIV9mb3JtQ29udHJvbC5jdXJyZW50KSB7XG4gICAgICAgIF9mb3JtQ29udHJvbC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgLi4uY3JlYXRlRm9ybUNvbnRyb2wocHJvcHMsICgpID0+IHVwZGF0ZUZvcm1TdGF0ZSgoZm9ybVN0YXRlKSA9PiAoeyAuLi5mb3JtU3RhdGUgfSkpKSxcbiAgICAgICAgICAgIGZvcm1TdGF0ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY29udHJvbCA9IF9mb3JtQ29udHJvbC5jdXJyZW50LmNvbnRyb2w7XG4gICAgY29udHJvbC5fb3B0aW9ucyA9IHByb3BzO1xuICAgIHVzZVN1YnNjcmliZSh7XG4gICAgICAgIHN1YmplY3Q6IGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLFxuICAgICAgICBuZXh0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW5kZXJGb3JtU3RhdGUodmFsdWUsIGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlLCBjb250cm9sLl91cGRhdGVGb3JtU3RhdGUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRm9ybVN0YXRlKHsgLi4uY29udHJvbC5fZm9ybVN0YXRlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiBjb250cm9sLl9kaXNhYmxlRm9ybShwcm9wcy5kaXNhYmxlZCksIFtjb250cm9sLCBwcm9wcy5kaXNhYmxlZF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChjb250cm9sLl9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5KSB7XG4gICAgICAgICAgICBjb25zdCBpc0RpcnR5ID0gY29udHJvbC5fZ2V0RGlydHkoKTtcbiAgICAgICAgICAgIGlmIChpc0RpcnR5ICE9PSBmb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBpc0RpcnR5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wsIGZvcm1TdGF0ZS5pc0RpcnR5XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb3BzLnZhbHVlcyAmJiAhZGVlcEVxdWFsKHByb3BzLnZhbHVlcywgX3ZhbHVlcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29udHJvbC5fcmVzZXQocHJvcHMudmFsdWVzLCBjb250cm9sLl9vcHRpb25zLnJlc2V0T3B0aW9ucyk7XG4gICAgICAgICAgICBfdmFsdWVzLmN1cnJlbnQgPSBwcm9wcy52YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sLl9yZXNldERlZmF1bHRWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgIH0sIFtwcm9wcy52YWx1ZXMsIGNvbnRyb2xdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbnRyb2wuX3N0YXRlLm1vdW50KSB7XG4gICAgICAgICAgICBjb250cm9sLl91cGRhdGVWYWxpZCgpO1xuICAgICAgICAgICAgY29udHJvbC5fc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sLl9zdGF0ZS53YXRjaCkge1xuICAgICAgICAgICAgY29udHJvbC5fc3RhdGUud2F0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5jb250cm9sLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5fcmVtb3ZlVW5tb3VudGVkKCk7XG4gICAgfSk7XG4gICAgX2Zvcm1Db250cm9sLmN1cnJlbnQuZm9ybVN0YXRlID0gZ2V0UHJveHlGb3JtU3RhdGUoZm9ybVN0YXRlLCBjb250cm9sKTtcbiAgICByZXR1cm4gX2Zvcm1Db250cm9sLmN1cnJlbnQ7XG59XG5cbmV4cG9ydCB7IENvbnRyb2xsZXIsIEZvcm0sIEZvcm1Qcm92aWRlciwgYXBwZW5kRXJyb3JzLCBnZXQsIHNldCwgdXNlQ29udHJvbGxlciwgdXNlRmllbGRBcnJheSwgdXNlRm9ybSwgdXNlRm9ybUNvbnRleHQsIHVzZUZvcm1TdGF0ZSwgdXNlV2F0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJpc0NoZWNrQm94SW5wdXQiLCJlbGVtZW50IiwidHlwZSIsImlzRGF0ZU9iamVjdCIsInZhbHVlIiwiRGF0ZSIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNPYmplY3RUeXBlIiwiaXNPYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRFdmVudFZhbHVlIiwiZXZlbnQiLCJ0YXJnZXQiLCJjaGVja2VkIiwiZ2V0Tm9kZVBhcmVudE5hbWUiLCJuYW1lIiwic3Vic3RyaW5nIiwic2VhcmNoIiwiaXNOYW1lSW5GaWVsZEFycmF5IiwibmFtZXMiLCJoYXMiLCJpc1BsYWluT2JqZWN0IiwidGVtcE9iamVjdCIsInByb3RvdHlwZUNvcHkiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiaXNXZWIiLCJ3aW5kb3ciLCJIVE1MRWxlbWVudCIsImRvY3VtZW50IiwiY2xvbmVPYmplY3QiLCJkYXRhIiwiY29weSIsIlNldCIsIkJsb2IiLCJGaWxlTGlzdCIsImtleSIsImNvbXBhY3QiLCJmaWx0ZXIiLCJCb29sZWFuIiwiaXNVbmRlZmluZWQiLCJ2YWwiLCJ1bmRlZmluZWQiLCJnZXQiLCJvYmoiLCJwYXRoIiwiZGVmYXVsdFZhbHVlIiwicmVzdWx0Iiwic3BsaXQiLCJyZWR1Y2UiLCJpc0Jvb2xlYW4iLCJFVkVOVFMiLCJCTFVSIiwiRk9DVVNfT1VUIiwiQ0hBTkdFIiwiVkFMSURBVElPTl9NT0RFIiwib25CbHVyIiwib25DaGFuZ2UiLCJvblN1Ym1pdCIsIm9uVG91Y2hlZCIsImFsbCIsIklOUFVUX1ZBTElEQVRJT05fUlVMRVMiLCJtYXgiLCJtaW4iLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJwYXR0ZXJuIiwicmVxdWlyZWQiLCJ2YWxpZGF0ZSIsIkhvb2tGb3JtQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VGb3JtQ29udGV4dCIsInVzZUNvbnRleHQiLCJGb3JtUHJvdmlkZXIiLCJwcm9wcyIsImNoaWxkcmVuIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwiZ2V0UHJveHlGb3JtU3RhdGUiLCJmb3JtU3RhdGUiLCJjb250cm9sIiwibG9jYWxQcm94eUZvcm1TdGF0ZSIsImlzUm9vdCIsImRlZmF1bHRWYWx1ZXMiLCJfZGVmYXVsdFZhbHVlcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX2tleSIsIl9wcm94eUZvcm1TdGF0ZSIsImlzRW1wdHlPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwic2hvdWxkUmVuZGVyRm9ybVN0YXRlIiwiZm9ybVN0YXRlRGF0YSIsInVwZGF0ZUZvcm1TdGF0ZSIsImZpbmQiLCJjb252ZXJ0VG9BcnJheVBheWxvYWQiLCJzaG91bGRTdWJzY3JpYmVCeU5hbWUiLCJzaWduYWxOYW1lIiwiZXhhY3QiLCJzb21lIiwiY3VycmVudE5hbWUiLCJzdGFydHNXaXRoIiwidXNlU3Vic2NyaWJlIiwiX3Byb3BzIiwidXNlUmVmIiwiY3VycmVudCIsInVzZUVmZmVjdCIsInN1YnNjcmlwdGlvbiIsImRpc2FibGVkIiwic3ViamVjdCIsInN1YnNjcmliZSIsIm5leHQiLCJ1bnN1YnNjcmliZSIsInVzZUZvcm1TdGF0ZSIsIm1ldGhvZHMiLCJ1c2VTdGF0ZSIsIl9mb3JtU3RhdGUiLCJfbW91bnRlZCIsIl9sb2NhbFByb3h5Rm9ybVN0YXRlIiwiaXNEaXJ0eSIsImlzTG9hZGluZyIsImRpcnR5RmllbGRzIiwidG91Y2hlZEZpZWxkcyIsImlzVmFsaWRhdGluZyIsImlzVmFsaWQiLCJlcnJvcnMiLCJfbmFtZSIsIl91cGRhdGVGb3JtU3RhdGUiLCJfc3ViamVjdHMiLCJzdGF0ZSIsIl91cGRhdGVWYWxpZCIsImlzU3RyaW5nIiwiZ2VuZXJhdGVXYXRjaE91dHB1dCIsIl9uYW1lcyIsImZvcm1WYWx1ZXMiLCJpc0dsb2JhbCIsIndhdGNoIiwiYWRkIiwibWFwIiwiZmllbGROYW1lIiwid2F0Y2hBbGwiLCJ1c2VXYXRjaCIsInZhbHVlcyIsInVwZGF0ZVZhbHVlIiwiX2Zvcm1WYWx1ZXMiLCJfZ2V0V2F0Y2giLCJfcmVtb3ZlVW5tb3VudGVkIiwiaXNLZXkiLCJ0ZXN0Iiwic3RyaW5nVG9QYXRoIiwiaW5wdXQiLCJyZXBsYWNlIiwic2V0Iiwib2JqZWN0IiwiaW5kZXgiLCJ0ZW1wUGF0aCIsImxhc3RJbmRleCIsIm5ld1ZhbHVlIiwib2JqVmFsdWUiLCJpc05hTiIsInVzZUNvbnRyb2xsZXIiLCJzaG91bGRVbnJlZ2lzdGVyIiwiaXNBcnJheUZpZWxkIiwiYXJyYXkiLCJfcmVnaXN0ZXJQcm9wcyIsInJlZ2lzdGVyIiwicnVsZXMiLCJfc2hvdWxkVW5yZWdpc3RlckZpZWxkIiwiX29wdGlvbnMiLCJ1cGRhdGVNb3VudGVkIiwiZmllbGQiLCJfZmllbGRzIiwiX2YiLCJtb3VudCIsIl9zdGF0ZSIsImFjdGlvbiIsInVucmVnaXN0ZXIiLCJfdXBkYXRlRGlzYWJsZWRGaWVsZCIsImZpZWxkcyIsInVzZUNhbGxiYWNrIiwicmVmIiwiZWxtIiwiZm9jdXMiLCJzZWxlY3QiLCJzZXRDdXN0b21WYWxpZGl0eSIsIm1lc3NhZ2UiLCJyZXBvcnRWYWxpZGl0eSIsImZpZWxkU3RhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiaW52YWxpZCIsImVudW1lcmFibGUiLCJpc1RvdWNoZWQiLCJlcnJvciIsIkNvbnRyb2xsZXIiLCJyZW5kZXIiLCJQT1NUX1JFUVVFU1QiLCJGb3JtIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJtZXRob2QiLCJoZWFkZXJzIiwiZW5jVHlwZSIsIm9uRXJyb3IiLCJvblN1Y2Nlc3MiLCJ2YWxpZGF0ZVN0YXR1cyIsInJlc3QiLCJzdWJtaXQiLCJoYXNFcnJvciIsImhhbmRsZVN1Ym1pdCIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJmb3JtRGF0YUpzb24iLCJKU09OIiwic3RyaW5naWZ5IiwiX2EiLCJhcHBlbmQiLCJzaG91bGRTdHJpbmdpZnlTdWJtaXNzaW9uRGF0YSIsImluY2x1ZGVzIiwicmVzcG9uc2UiLCJmZXRjaCIsImJvZHkiLCJzdGF0dXMiLCJTdHJpbmciLCJpc1N1Ym1pdFN1Y2Nlc3NmdWwiLCJzZXRFcnJvciIsIkZyYWdtZW50Iiwibm9WYWxpZGF0ZSIsImFwcGVuZEVycm9ycyIsInZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSIsInR5cGVzIiwiZ2VuZXJhdGVJZCIsImQiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImMiLCJyIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwiZ2V0Rm9jdXNGaWVsZE5hbWUiLCJvcHRpb25zIiwic2hvdWxkRm9jdXMiLCJmb2N1c05hbWUiLCJmb2N1c0luZGV4IiwiZ2V0VmFsaWRhdGlvbk1vZGVzIiwibW9kZSIsImlzT25TdWJtaXQiLCJpc09uQmx1ciIsImlzT25DaGFuZ2UiLCJpc09uQWxsIiwiaXNPblRvdWNoIiwiaXNXYXRjaGVkIiwiaXNCbHVyRXZlbnQiLCJ3YXRjaE5hbWUiLCJzbGljZSIsIml0ZXJhdGVGaWVsZHNCeUFjdGlvbiIsImZpZWxkc05hbWVzIiwiYWJvcnRFYXJseSIsImN1cnJlbnRGaWVsZCIsInJlZnMiLCJ1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yIiwiZmllbGRBcnJheUVycm9ycyIsImlzRmlsZUlucHV0IiwiaXNGdW5jdGlvbiIsImlzSFRNTEVsZW1lbnQiLCJvd25lciIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzTWVzc2FnZSIsImlzUmFkaW9JbnB1dCIsImlzUmVnZXgiLCJSZWdFeHAiLCJkZWZhdWx0UmVzdWx0IiwidmFsaWRSZXN1bHQiLCJnZXRDaGVja2JveFZhbHVlIiwib3B0aW9uIiwiYXR0cmlidXRlcyIsImRlZmF1bHRSZXR1cm4iLCJnZXRSYWRpb1ZhbHVlIiwicHJldmlvdXMiLCJnZXRWYWxpZGF0ZUVycm9yIiwiZXZlcnkiLCJnZXRWYWx1ZUFuZE1lc3NhZ2UiLCJ2YWxpZGF0aW9uRGF0YSIsInZhbGlkYXRlRmllbGQiLCJzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uIiwiaXNGaWVsZEFycmF5IiwidmFsdWVBc051bWJlciIsImlucHV0VmFsdWUiLCJpbnB1dFJlZiIsImlzUmFkaW8iLCJpc0NoZWNrQm94IiwiaXNSYWRpb09yQ2hlY2tib3giLCJpc0VtcHR5IiwiYXBwZW5kRXJyb3JzQ3VycnkiLCJiaW5kIiwiZ2V0TWluTWF4TWVzc2FnZSIsImV4Y2VlZE1heCIsIm1heExlbmd0aE1lc3NhZ2UiLCJtaW5MZW5ndGhNZXNzYWdlIiwibWF4VHlwZSIsIm1pblR5cGUiLCJleGNlZWRNaW4iLCJtYXhPdXRwdXQiLCJtaW5PdXRwdXQiLCJ2YWx1ZU51bWJlciIsInZhbHVlRGF0ZSIsInZhbHVlQXNEYXRlIiwiY29udmVydFRpbWVUb0RhdGUiLCJ0aW1lIiwidG9EYXRlU3RyaW5nIiwiaXNUaW1lIiwiaXNXZWVrIiwibWF4TGVuZ3RoT3V0cHV0IiwibWluTGVuZ3RoT3V0cHV0IiwicGF0dGVyblZhbHVlIiwibWF0Y2giLCJ2YWxpZGF0ZUVycm9yIiwidmFsaWRhdGlvblJlc3VsdCIsImZpbGxFbXB0eUFycmF5IiwiaW5zZXJ0IiwibW92ZUFycmF5QXQiLCJmcm9tIiwidG8iLCJzcGxpY2UiLCJwcmVwZW5kIiwicmVtb3ZlQXRJbmRleGVzIiwiaW5kZXhlcyIsImkiLCJ0ZW1wIiwicmVtb3ZlQXJyYXlBdCIsInNvcnQiLCJhIiwiYiIsInN3YXBBcnJheUF0IiwiaW5kZXhBIiwiaW5kZXhCIiwiYmFzZUdldCIsInVwZGF0ZVBhdGgiLCJpc0VtcHR5QXJyYXkiLCJ1bnNldCIsInBhdGhzIiwiY2hpbGRPYmplY3QiLCJ1cGRhdGVBdCIsImZpZWxkVmFsdWVzIiwidXNlRmllbGRBcnJheSIsImtleU5hbWUiLCJzZXRGaWVsZHMiLCJfZ2V0RmllbGRBcnJheSIsImlkcyIsIl9maWVsZElkcyIsIl9hY3Rpb25lZCIsImZpZWxkQXJyYXlOYW1lIiwidXBkYXRlVmFsdWVzIiwidXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMiLCJfdXBkYXRlRmllbGRBcnJheSIsImFwcGVuZCQxIiwiYXBwZW5kVmFsdWUiLCJhcmdBIiwicHJlcGVuZCQxIiwicHJlcGVuZFZhbHVlIiwicmVtb3ZlIiwiaW5zZXJ0JDEiLCJpbnNlcnRWYWx1ZSIsImFyZ0IiLCJzd2FwIiwibW92ZSIsInVwZGF0ZSIsIml0ZW0iLCJpc1N1Ym1pdHRlZCIsInJlc29sdmVyIiwiX2V4ZWN1dGVTY2hlbWEiLCJ0aGVuIiwiZXhpc3RpbmdFcnJvciIsImNyaXRlcmlhTW9kZSIsInVzZU1lbW8iLCJjcmVhdGVTdWJqZWN0IiwiX29ic2VydmVycyIsIm9ic2VydmVyIiwicHVzaCIsIm8iLCJvYnNlcnZlcnMiLCJpc1ByaW1pdGl2ZSIsImRlZXBFcXVhbCIsIm9iamVjdDEiLCJvYmplY3QyIiwiZ2V0VGltZSIsImtleXMxIiwia2V5czIiLCJ2YWwxIiwidmFsMiIsImlzTXVsdGlwbGVTZWxlY3QiLCJsaXZlIiwiaXNDb25uZWN0ZWQiLCJvYmplY3RIYXNGdW5jdGlvbiIsIm1hcmtGaWVsZHNEaXJ0eSIsImlzUGFyZW50Tm9kZUFycmF5IiwiZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyIsImRpcnR5RmllbGRzRnJvbVZhbHVlcyIsImdldERpcnR5RmllbGRzIiwiZ2V0RmllbGRWYWx1ZUFzIiwic2V0VmFsdWVBcyIsIk5hTiIsImdldEZpZWxkVmFsdWUiLCJmaWxlcyIsInNlbGVjdGVkT3B0aW9ucyIsImdldFJlc29sdmVyT3B0aW9ucyIsImdldFJ1bGVWYWx1ZSIsInJ1bGUiLCJzb3VyY2UiLCJoYXNWYWxpZGF0aW9uIiwic2NoZW1hRXJyb3JMb29rdXAiLCJqb2luIiwiZm91bmRFcnJvciIsInBvcCIsInNraXBWYWxpZGF0aW9uIiwicmVWYWxpZGF0ZU1vZGUiLCJ1bnNldEVtcHR5QXJyYXkiLCJkZWZhdWx0T3B0aW9ucyIsInNob3VsZEZvY3VzRXJyb3IiLCJjcmVhdGVGb3JtQ29udHJvbCIsImZsdXNoUm9vdFJlbmRlciIsInN1Ym1pdENvdW50IiwiaXNTdWJtaXR0aW5nIiwidW5Nb3VudCIsImRlbGF5RXJyb3JDYWxsYmFjayIsInRpbWVyIiwic2hvdWxkQ2FwdHVyZURpcnR5RmllbGRzIiwicmVzZXRPcHRpb25zIiwia2VlcERpcnR5VmFsdWVzIiwidmFsaWRhdGlvbk1vZGVCZWZvcmVTdWJtaXQiLCJ2YWxpZGF0aW9uTW9kZUFmdGVyU3VibWl0Iiwic2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMiLCJkZWJvdW5jZSIsImNhbGxiYWNrIiwid2FpdCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJzaG91bGRVcGRhdGVWYWxpZCIsImV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbiIsIl91cGRhdGVJc1ZhbGlkYXRpbmciLCJhcmdzIiwic2hvdWxkU2V0VmFsdWVzIiwic2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUiLCJfZ2V0RGlydHkiLCJ1cGRhdGVFcnJvcnMiLCJ1cGRhdGVWYWxpZEFuZFZhbHVlIiwic2hvdWxkU2tpcFNldFZhbHVlQXMiLCJkZWZhdWx0Q2hlY2tlZCIsInNldEZpZWxkVmFsdWUiLCJ1cGRhdGVUb3VjaEFuZERpcnR5IiwiZmllbGRWYWx1ZSIsInNob3VsZERpcnR5Iiwic2hvdWxkUmVuZGVyIiwic2hvdWxkVXBkYXRlRmllbGQiLCJpc1ByZXZpb3VzRGlydHkiLCJvdXRwdXQiLCJpc0N1cnJlbnRGaWVsZFByaXN0aW5lIiwiaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCIsInNob3VsZFJlbmRlckJ5RXJyb3IiLCJwcmV2aW91c0ZpZWxkRXJyb3IiLCJkZWxheUVycm9yIiwidXBkYXRlZEZvcm1TdGF0ZSIsImNvbnRleHQiLCJleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUiLCJzaG91bGRPbmx5Q2hlY2tWYWxpZCIsInZhbGlkIiwiaXNGaWVsZEFycmF5Um9vdCIsImZpZWxkRXJyb3IiLCJnZXRWYWx1ZXMiLCJmaWVsZFJlZmVyZW5jZSIsImZvckVhY2giLCJvcHRpb25SZWYiLCJzZWxlY3RlZCIsImNoZWNrYm94UmVmIiwicmFkaW9SZWYiLCJzaG91bGRUb3VjaCIsInNob3VsZFZhbGlkYXRlIiwidHJpZ2dlciIsInNldFZhbHVlcyIsImZpZWxkS2V5Iiwic2V0VmFsdWUiLCJjbG9uZVZhbHVlIiwiaXNGaWVsZFZhbHVlVXBkYXRlZCIsImdldEN1cnJlbnRGaWVsZFZhbHVlIiwiX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQiLCJOdW1iZXIiLCJzaG91bGRTa2lwVmFsaWRhdGlvbiIsImRlcHMiLCJ3YXRjaGVkIiwicHJldmlvdXNFcnJvckxvb2t1cFJlc3VsdCIsImVycm9yTG9va3VwUmVzdWx0IiwiX2ZvY3VzSW5wdXQiLCJmaWVsZE5hbWVzIiwiUHJvbWlzZSIsImdldEZpZWxkU3RhdGUiLCJjbGVhckVycm9ycyIsImlucHV0TmFtZSIsInBheWxvYWQiLCJkZWxldGUiLCJrZWVwVmFsdWUiLCJrZWVwRXJyb3IiLCJrZWVwRGlydHkiLCJrZWVwVG91Y2hlZCIsImtlZXBEZWZhdWx0VmFsdWUiLCJrZWVwSXNWYWxpZCIsImRpc2FibGVkSXNEZWZpbmVkIiwicHJvZ3Jlc3NpdmUiLCJmaWVsZFJlZiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyYWRpb09yQ2hlY2tib3giLCJfZm9jdXNFcnJvciIsIl9kaXNhYmxlRm9ybSIsIm9uVmFsaWQiLCJvbkludmFsaWQiLCJlIiwicHJldmVudERlZmF1bHQiLCJwZXJzaXN0IiwicmVzZXRGaWVsZCIsIl9yZXNldCIsImtlZXBTdGF0ZU9wdGlvbnMiLCJ1cGRhdGVkVmFsdWVzIiwiY2xvbmVVcGRhdGVkVmFsdWVzIiwia2VlcERlZmF1bHRWYWx1ZXMiLCJrZWVwVmFsdWVzIiwiZm9ybSIsImNsb3Nlc3QiLCJyZXNldCIsImtlZXBTdWJtaXRDb3VudCIsImtlZXBJc1N1Ym1pdHRlZCIsImtlZXBFcnJvcnMiLCJrZWVwSXNTdWJtaXRTdWNjZXNzZnVsIiwic2V0Rm9jdXMiLCJzaG91bGRTZWxlY3QiLCJfcmVzZXREZWZhdWx0VmFsdWVzIiwidXNlRm9ybSIsIl9mb3JtQ29udHJvbCIsIl92YWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs\n");

/***/ })

};
;